// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: message.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum SensorPacketTypes: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknownPacketType // = 0
  case ppgRed // = 1
  case ppgIr // = 2
  case spectrometer // = 3
  case bme // = 4
  case co2 // = 5
  case imu // = 6
  case thermopile // = 7
  case lux // = 8
  case lidar // = 9
  case mic // = 10
  case sht // = 11
  case sgp // = 12
  case blink // = 13
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknownPacketType
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownPacketType
    case 1: self = .ppgRed
    case 2: self = .ppgIr
    case 3: self = .spectrometer
    case 4: self = .bme
    case 5: self = .co2
    case 6: self = .imu
    case 7: self = .thermopile
    case 8: self = .lux
    case 9: self = .lidar
    case 10: self = .mic
    case 11: self = .sht
    case 12: self = .sgp
    case 13: self = .blink
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknownPacketType: return 0
    case .ppgRed: return 1
    case .ppgIr: return 2
    case .spectrometer: return 3
    case .bme: return 4
    case .co2: return 5
    case .imu: return 6
    case .thermopile: return 7
    case .lux: return 8
    case .lidar: return 9
    case .mic: return 10
    case .sht: return 11
    case .sgp: return 12
    case .blink: return 13
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension SensorPacketTypes: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [SensorPacketTypes] = [
    .unknownPacketType,
    .ppgRed,
    .ppgIr,
    .spectrometer,
    .bme,
    .co2,
    .imu,
    .thermopile,
    .lux,
    .lidar,
    .mic,
    .sht,
    .sgp,
    .blink,
  ]
}

#endif  // swift(>=4.2)

public enum Tsl2591Gain: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  //// low gain (1x)
  case tsl2722Gain1X // = 0

  //// medium gain (25x)
  case tsl2722Gain8X // = 1

  //// medium gain (428x)
  case tsl2722Gain16X // = 2

  //// max gain (9876x)
  case tsl2722Gain120X // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .tsl2722Gain1X
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .tsl2722Gain1X
    case 1: self = .tsl2722Gain8X
    case 2: self = .tsl2722Gain16X
    case 3: self = .tsl2722Gain120X
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .tsl2722Gain1X: return 0
    case .tsl2722Gain8X: return 1
    case .tsl2722Gain16X: return 2
    case .tsl2722Gain120X: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Tsl2591Gain: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Tsl2591Gain] = [
    .tsl2722Gain1X,
    .tsl2722Gain8X,
    .tsl2722Gain16X,
    .tsl2722Gain120X,
  ]
}

#endif  // swift(>=4.2)

public enum Tsl2591IntegrationTime: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// 699 millis
  case tsl2722Integrationtime600Ms // = 0

  /// 2.73 millis
  case tsl2722Integrationtime273Ms // = 255

  /// 27.3 millis
  case tsl2722Integrationtime2730Ms // = 246

  /// 101 millis
  case tsl2722Integrationtime101Ms // = 219

  /// 175 millis
  case tsl2722Integrationtime175Ms // = 192
  case UNRECOGNIZED(Int)

  public init() {
    self = .tsl2722Integrationtime600Ms
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .tsl2722Integrationtime600Ms
    case 192: self = .tsl2722Integrationtime175Ms
    case 219: self = .tsl2722Integrationtime101Ms
    case 246: self = .tsl2722Integrationtime2730Ms
    case 255: self = .tsl2722Integrationtime273Ms
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .tsl2722Integrationtime600Ms: return 0
    case .tsl2722Integrationtime175Ms: return 192
    case .tsl2722Integrationtime101Ms: return 219
    case .tsl2722Integrationtime2730Ms: return 246
    case .tsl2722Integrationtime273Ms: return 255
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Tsl2591IntegrationTime: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Tsl2591IntegrationTime] = [
    .tsl2722Integrationtime600Ms,
    .tsl2722Integrationtime273Ms,
    .tsl2722Integrationtime2730Ms,
    .tsl2722Integrationtime101Ms,
    .tsl2722Integrationtime175Ms,
  ]
}

#endif  // swift(>=4.2)

public enum Sht45_precision: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case sht4XHighPrecision // = 0
  case sht4XMedPrecision // = 1
  case sht4XLowPrecision // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .sht4XHighPrecision
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .sht4XHighPrecision
    case 1: self = .sht4XMedPrecision
    case 2: self = .sht4XLowPrecision
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .sht4XHighPrecision: return 0
    case .sht4XMedPrecision: return 1
    case .sht4XLowPrecision: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Sht45_precision: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Sht45_precision] = [
    .sht4XHighPrecision,
    .sht4XMedPrecision,
    .sht4XLowPrecision,
  ]
}

#endif  // swift(>=4.2)

///* Optional pre-heater configuration setting
public enum Sht45_heater: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case sht4XNoHeater // = 0
  case sht4XHighHeater1S // = 1
  case sht4XHighHeater100Ms // = 2
  case sht4XMedHeater1S // = 3
  case sht4XMedHeater100Ms // = 4
  case sht4XLowHeater1S // = 5
  case sht4XLowHeater100Ms // = 6
  case UNRECOGNIZED(Int)

  public init() {
    self = .sht4XNoHeater
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .sht4XNoHeater
    case 1: self = .sht4XHighHeater1S
    case 2: self = .sht4XHighHeater100Ms
    case 3: self = .sht4XMedHeater1S
    case 4: self = .sht4XMedHeater100Ms
    case 5: self = .sht4XLowHeater1S
    case 6: self = .sht4XLowHeater100Ms
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .sht4XNoHeater: return 0
    case .sht4XHighHeater1S: return 1
    case .sht4XHighHeater100Ms: return 2
    case .sht4XMedHeater1S: return 3
    case .sht4XMedHeater100Ms: return 4
    case .sht4XLowHeater1S: return 5
    case .sht4XLowHeater100Ms: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Sht45_heater: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Sht45_heater] = [
    .sht4XNoHeater,
    .sht4XHighHeater1S,
    .sht4XHighHeater100Ms,
    .sht4XMedHeater1S,
    .sht4XMedHeater100Ms,
    .sht4XLowHeater1S,
    .sht4XLowHeater100Ms,
  ]
}

#endif  // swift(>=4.2)

public enum Thermopile_location: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case tipOfNose // = 0
  case noseBridge // = 1
  case frontTemple // = 2
  case midTemple // = 3
  case rearTemple // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .tipOfNose
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .tipOfNose
    case 1: self = .noseBridge
    case 2: self = .frontTemple
    case 3: self = .midTemple
    case 4: self = .rearTemple
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .tipOfNose: return 0
    case .noseBridge: return 1
    case .frontTemple: return 2
    case .midTemple: return 3
    case .rearTemple: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Thermopile_location: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Thermopile_location] = [
    .tipOfNose,
    .noseBridge,
    .frontTemple,
    .midTemple,
    .rearTemple,
  ]
}

#endif  // swift(>=4.2)

///* defined by Bosch
public enum BME680_accuracy: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unreliable // = 0
  case lowAccuracy // = 1
  case mediumAccuracy // = 2
  case highAccuracy // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .unreliable
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unreliable
    case 1: self = .lowAccuracy
    case 2: self = .mediumAccuracy
    case 3: self = .highAccuracy
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unreliable: return 0
    case .lowAccuracy: return 1
    case .mediumAccuracy: return 2
    case .highAccuracy: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension BME680_accuracy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [BME680_accuracy] = [
    .unreliable,
    .lowAccuracy,
    .mediumAccuracy,
    .highAccuracy,
  ]
}

#endif  // swift(>=4.2)

///* defined by Bosch
public enum BME680_signal_id: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case undefined // = 0
  case iaq // = 1
  case staticIaq // = 2
  case co2Eq // = 3
  case breathVocEq // = 4
  case rawTemperature // = 6
  case rawPressure // = 7
  case rawHumidity // = 8
  case rawGas // = 9
  case stabilizationStatus // = 12
  case runInStatus // = 13
  case sensorHeatCompenTemp // = 14
  case heatCompenHumid // = 15
  case gasPercentage // = 21
  case UNRECOGNIZED(Int)

  public init() {
    self = .undefined
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .undefined
    case 1: self = .iaq
    case 2: self = .staticIaq
    case 3: self = .co2Eq
    case 4: self = .breathVocEq
    case 6: self = .rawTemperature
    case 7: self = .rawPressure
    case 8: self = .rawHumidity
    case 9: self = .rawGas
    case 12: self = .stabilizationStatus
    case 13: self = .runInStatus
    case 14: self = .sensorHeatCompenTemp
    case 15: self = .heatCompenHumid
    case 21: self = .gasPercentage
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .undefined: return 0
    case .iaq: return 1
    case .staticIaq: return 2
    case .co2Eq: return 3
    case .breathVocEq: return 4
    case .rawTemperature: return 6
    case .rawPressure: return 7
    case .rawHumidity: return 8
    case .rawGas: return 9
    case .stabilizationStatus: return 12
    case .runInStatus: return 13
    case .sensorHeatCompenTemp: return 14
    case .heatCompenHumid: return 15
    case .gasPercentage: return 21
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension BME680_signal_id: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [BME680_signal_id] = [
    .undefined,
    .iaq,
    .staticIaq,
    .co2Eq,
    .breathVocEq,
    .rawTemperature,
    .rawPressure,
    .rawHumidity,
    .rawGas,
    .stabilizationStatus,
    .runInStatus,
    .sensorHeatCompenTemp,
    .heatCompenHumid,
    .gasPercentage,
  ]
}

#endif  // swift(>=4.2)

///* defined in spectrometer (AS7341) datasheet
public enum Spec_gain: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case gain05X // = 0
  case gain1X // = 1
  case gain2X // = 2
  case gain4X // = 3
  case gain8X // = 4
  case gain16X // = 5
  case gain32X // = 6
  case gain64X // = 7
  case gain128X // = 8
  case gain256X // = 9
  case gain512X // = 10
  case UNRECOGNIZED(Int)

  public init() {
    self = .gain05X
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .gain05X
    case 1: self = .gain1X
    case 2: self = .gain2X
    case 3: self = .gain4X
    case 4: self = .gain8X
    case 5: self = .gain16X
    case 6: self = .gain32X
    case 7: self = .gain64X
    case 8: self = .gain128X
    case 9: self = .gain256X
    case 10: self = .gain512X
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .gain05X: return 0
    case .gain1X: return 1
    case .gain2X: return 2
    case .gain4X: return 3
    case .gain8X: return 4
    case .gain16X: return 5
    case .gain32X: return 6
    case .gain64X: return 7
    case .gain128X: return 8
    case .gain256X: return 9
    case .gain512X: return 10
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Spec_gain: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Spec_gain] = [
    .gain05X,
    .gain1X,
    .gain2X,
    .gain4X,
    .gain8X,
    .gain16X,
    .gain32X,
    .gain64X,
    .gain128X,
    .gain256X,
    .gain512X,
  ]
}

#endif  // swift(>=4.2)

///* defined in IMU (ICM20948) datasheet
public enum IMU_gyro_cutoff: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case icm20XGyroFreq1966Hz // = 0
  case icm20XGyroFreq1518Hz // = 1
  case icm20XGyroFreq1195Hz // = 2
  case icm20XGyroFreq512Hz // = 3
  case icm20XGyroFreq239Hz // = 4
  case icm20XGyroFreq116Hz // = 5
  case icm20XGyroFreq57Hz // = 6
  case icm20XGyroFreq3614Hz // = 7
  case UNRECOGNIZED(Int)

  public init() {
    self = .icm20XGyroFreq1966Hz
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .icm20XGyroFreq1966Hz
    case 1: self = .icm20XGyroFreq1518Hz
    case 2: self = .icm20XGyroFreq1195Hz
    case 3: self = .icm20XGyroFreq512Hz
    case 4: self = .icm20XGyroFreq239Hz
    case 5: self = .icm20XGyroFreq116Hz
    case 6: self = .icm20XGyroFreq57Hz
    case 7: self = .icm20XGyroFreq3614Hz
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .icm20XGyroFreq1966Hz: return 0
    case .icm20XGyroFreq1518Hz: return 1
    case .icm20XGyroFreq1195Hz: return 2
    case .icm20XGyroFreq512Hz: return 3
    case .icm20XGyroFreq239Hz: return 4
    case .icm20XGyroFreq116Hz: return 5
    case .icm20XGyroFreq57Hz: return 6
    case .icm20XGyroFreq3614Hz: return 7
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension IMU_gyro_cutoff: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [IMU_gyro_cutoff] = [
    .icm20XGyroFreq1966Hz,
    .icm20XGyroFreq1518Hz,
    .icm20XGyroFreq1195Hz,
    .icm20XGyroFreq512Hz,
    .icm20XGyroFreq239Hz,
    .icm20XGyroFreq116Hz,
    .icm20XGyroFreq57Hz,
    .icm20XGyroFreq3614Hz,
  ]
}

#endif  // swift(>=4.2)

///* defined in IMU (ICM20948) datasheet
public enum IMU_gyro_range: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case range250Dps // = 0
  case range500Dps // = 1
  case range1000Dps // = 2
  case range2000Dps // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .range250Dps
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .range250Dps
    case 1: self = .range500Dps
    case 2: self = .range1000Dps
    case 3: self = .range2000Dps
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .range250Dps: return 0
    case .range500Dps: return 1
    case .range1000Dps: return 2
    case .range2000Dps: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension IMU_gyro_range: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [IMU_gyro_range] = [
    .range250Dps,
    .range500Dps,
    .range1000Dps,
    .range2000Dps,
  ]
}

#endif  // swift(>=4.2)

///* defined in IMU (ICM20948) datasheet
public enum IMU_accel_cutoff: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case undefinedAccelCutoff // = 0
  case icm20XAccelFreq2460Hz // = 1
  case icm20XAccelFreq1114Hz // = 2
  case icm20XAccelFreq504Hz // = 3
  case icm20XAccelFreq239Hz // = 4
  case icm20XAccelFreq115Hz // = 5
  case icm20XAccelFreq57Hz // = 6
  case icm20XAccelFreq473Hz // = 7
  case UNRECOGNIZED(Int)

  public init() {
    self = .undefinedAccelCutoff
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .undefinedAccelCutoff
    case 1: self = .icm20XAccelFreq2460Hz
    case 2: self = .icm20XAccelFreq1114Hz
    case 3: self = .icm20XAccelFreq504Hz
    case 4: self = .icm20XAccelFreq239Hz
    case 5: self = .icm20XAccelFreq115Hz
    case 6: self = .icm20XAccelFreq57Hz
    case 7: self = .icm20XAccelFreq473Hz
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .undefinedAccelCutoff: return 0
    case .icm20XAccelFreq2460Hz: return 1
    case .icm20XAccelFreq1114Hz: return 2
    case .icm20XAccelFreq504Hz: return 3
    case .icm20XAccelFreq239Hz: return 4
    case .icm20XAccelFreq115Hz: return 5
    case .icm20XAccelFreq57Hz: return 6
    case .icm20XAccelFreq473Hz: return 7
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension IMU_accel_cutoff: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [IMU_accel_cutoff] = [
    .undefinedAccelCutoff,
    .icm20XAccelFreq2460Hz,
    .icm20XAccelFreq1114Hz,
    .icm20XAccelFreq504Hz,
    .icm20XAccelFreq239Hz,
    .icm20XAccelFreq115Hz,
    .icm20XAccelFreq57Hz,
    .icm20XAccelFreq473Hz,
  ]
}

#endif  // swift(>=4.2)

///* defined in IMU (ICM20948) datasheet
public enum IMU_accel_range: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case range2G // = 0
  case range4G // = 1
  case range8G // = 2
  case range16G // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .range2G
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .range2G
    case 1: self = .range4G
    case 2: self = .range8G
    case 3: self = .range16G
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .range2G: return 0
    case .range4G: return 1
    case .range8G: return 2
    case .range16G: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension IMU_accel_range: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [IMU_accel_range] = [
    .range2G,
    .range4G,
    .range8G,
    .range16G,
  ]
}

#endif  // swift(>=4.2)

///* defined in IMU (ICM20948) datasheet
public enum IMU_mag_cutoff: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case undefinedMagCutoff // = 0
  case icm20XMag10Hz // = 2
  case icm20XMag20Hz // = 4
  case icm20XMag50Hz // = 6
  case icm20XMag100Hz // = 8
  case UNRECOGNIZED(Int)

  public init() {
    self = .undefinedMagCutoff
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .undefinedMagCutoff
    case 2: self = .icm20XMag10Hz
    case 4: self = .icm20XMag20Hz
    case 6: self = .icm20XMag50Hz
    case 8: self = .icm20XMag100Hz
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .undefinedMagCutoff: return 0
    case .icm20XMag10Hz: return 2
    case .icm20XMag20Hz: return 4
    case .icm20XMag50Hz: return 6
    case .icm20XMag100Hz: return 8
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension IMU_mag_cutoff: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [IMU_mag_cutoff] = [
    .undefinedMagCutoff,
    .icm20XMag10Hz,
    .icm20XMag20Hz,
    .icm20XMag50Hz,
    .icm20XMag100Hz,
  ]
}

#endif  // swift(>=4.2)

public struct SensorPacketHeader {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var systemUid: UInt32 = 0

  public var msFromStart: UInt32 = 0

  public var epoch: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct LuxPacket {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var packetIndex: UInt32 = 0

  public var samplePeriod: UInt32 = 0

  public var gain: Tsl2591Gain = .tsl2722Gain1X

  public var integrationTime: Tsl2591IntegrationTime = .tsl2722Integrationtime600Ms

  public var payload: [LuxPacket.Payload] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Payload {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var lux: UInt32 = 0

    public var timestampUnix: UInt32 = 0

    public var timestampMsFromStart: UInt32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct SGPPacket {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var packetIndex: UInt32 = 0

  public var samplePeriod: UInt32 = 0

  public var payload: [SGPPacket.Payload] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Payload {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var timestampUnix: UInt32 = 0

    public var timestampMsFromStart: UInt32 = 0

    public var srawVoc: UInt32 = 0

    public var srawNox: UInt32 = 0

    public var vocIndexValue: Int32 = 0

    public var noxIndexValue: Int32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct BMEPacket {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var packetIndex: UInt32 = 0

  public var samplePeriod: UInt32 = 0

  public var payload: [BMEPacket.Payload] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Payload {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var timestampSensor: UInt64 = 0

    public var timestampUnix: UInt32 = 0

    public var timestampMsFromStart: UInt32 = 0

    public var signal: Float = 0

    public var signalDimensions: UInt32 = 0

    public var sensorID: BME680_signal_id = .undefined

    public var accuracy: BME680_accuracy = .unreliable

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct Blink_saturation_settings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var diodeTurnedOff: Bool = false

  public var diodeSaturationLowerThresh: UInt32 = 0

  public var diodeSaturationUpperThresh: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct BlinkBytePayload {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sample: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct BlinkHighResPayload {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sample: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct BlinkPacket {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var packetIndex: UInt32 = 0

  public var saturationSettings: Blink_saturation_settings {
    get {return _saturationSettings ?? Blink_saturation_settings()}
    set {_saturationSettings = newValue}
  }
  /// Returns true if `saturationSettings` has been explicitly set.
  public var hasSaturationSettings: Bool {return self._saturationSettings != nil}
  /// Clears the value of `saturationSettings`. Subsequent reads from it will return its default value.
  public mutating func clearSaturationSettings() {self._saturationSettings = nil}

  public var sampleRate: UInt32 = 0

  public var payload: BlinkPacket.OneOf_Payload? = nil

  public var payloadByte: BlinkBytePayload {
    get {
      if case .payloadByte(let v)? = payload {return v}
      return BlinkBytePayload()
    }
    set {payload = .payloadByte(newValue)}
  }

  public var payloadHighRes: BlinkHighResPayload {
    get {
      if case .payloadHighRes(let v)? = payload {return v}
      return BlinkHighResPayload()
    }
    set {payload = .payloadHighRes(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    case payloadByte(BlinkBytePayload)
    case payloadHighRes(BlinkHighResPayload)

  #if !swift(>=4.1)
    public static func ==(lhs: BlinkPacket.OneOf_Payload, rhs: BlinkPacket.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.payloadByte, .payloadByte): return {
        guard case .payloadByte(let l) = lhs, case .payloadByte(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.payloadHighRes, .payloadHighRes): return {
        guard case .payloadHighRes(let l) = lhs, case .payloadHighRes(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _saturationSettings: Blink_saturation_settings? = nil
}

public struct SHTPacket {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var packetIndex: UInt32 = 0

  public var samplePeriod: UInt32 = 0

  public var precision: Sht45_precision = .sht4XHighPrecision

  public var heater: Sht45_heater = .sht4XNoHeater

  public var payload: [SHTPacket.Payload] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Payload {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var timestampUnix: UInt32 = 0

    public var timestampMsFromStart: UInt32 = 0

    public var temperature: Float = 0

    public var humidity: Float = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct SpecPacket {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var packetIndex: UInt32 = 0

  public var samplePeriod: UInt32 = 0

  public var integrationTime: UInt32 = 0

  public var integrationStep: UInt32 = 0

  public var gain: Spec_gain = .gain05X

  public var payload: [SpecPacket.Payload] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Payload {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var band415: UInt32 = 0

    public var band445: UInt32 = 0

    public var band480: UInt32 = 0

    public var band515: UInt32 = 0

    public var bandClear1: UInt32 = 0

    public var bandNir1: UInt32 = 0

    public var band555: UInt32 = 0

    public var band590: UInt32 = 0

    public var band630: UInt32 = 0

    public var band680: UInt32 = 0

    public var bandClear2: UInt32 = 0

    public var bandNir2: UInt32 = 0

    public var flicker: UInt32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct ThermPacket {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var packetIndex: UInt32 = 0

  public var samplePeriod: UInt32 = 0

  public var payload: [ThermPacket.Payload] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Payload {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var descriptor: Thermopile_location = .tipOfNose

    public var timestampUnix: UInt32 = 0

    public var timestampMsFromStart: UInt32 = 0

    public var ambientRaw: UInt32 = 0

    public var objectRaw: UInt32 = 0

    public var ambientTemp: Float = 0

    public var objectTemp: Float = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct IMU_Accel_Settings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var cutoff: IMU_accel_cutoff {
    get {return _cutoff ?? .undefinedAccelCutoff}
    set {_cutoff = newValue}
  }
  /// Returns true if `cutoff` has been explicitly set.
  public var hasCutoff: Bool {return self._cutoff != nil}
  /// Clears the value of `cutoff`. Subsequent reads from it will return its default value.
  public mutating func clearCutoff() {self._cutoff = nil}

  public var range: IMU_accel_range = .range2G

  public var sampleRateDivisor: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _cutoff: IMU_accel_cutoff? = nil
}

public struct IMU_Gyro_Settings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var cutoff: IMU_gyro_cutoff {
    get {return _cutoff ?? .icm20XGyroFreq1966Hz}
    set {_cutoff = newValue}
  }
  /// Returns true if `cutoff` has been explicitly set.
  public var hasCutoff: Bool {return self._cutoff != nil}
  /// Clears the value of `cutoff`. Subsequent reads from it will return its default value.
  public mutating func clearCutoff() {self._cutoff = nil}

  public var range: IMU_gyro_range = .range250Dps

  public var sampleRateDivisor: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _cutoff: IMU_gyro_cutoff? = nil
}

public struct IMUPacket {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var packetIndex: UInt32 = 0

  public var accelSettings: IMU_Accel_Settings {
    get {return _accelSettings ?? IMU_Accel_Settings()}
    set {_accelSettings = newValue}
  }
  /// Returns true if `accelSettings` has been explicitly set.
  public var hasAccelSettings: Bool {return self._accelSettings != nil}
  /// Clears the value of `accelSettings`. Subsequent reads from it will return its default value.
  public mutating func clearAccelSettings() {self._accelSettings = nil}

  public var gyroSettings: IMU_Gyro_Settings {
    get {return _gyroSettings ?? IMU_Gyro_Settings()}
    set {_gyroSettings = newValue}
  }
  /// Returns true if `gyroSettings` has been explicitly set.
  public var hasGyroSettings: Bool {return self._gyroSettings != nil}
  /// Clears the value of `gyroSettings`. Subsequent reads from it will return its default value.
  public mutating func clearGyroSettings() {self._gyroSettings = nil}

  public var payload: IMUPacket.Payload {
    get {return _payload ?? IMUPacket.Payload()}
    set {_payload = newValue}
  }
  /// Returns true if `payload` has been explicitly set.
  public var hasPayload: Bool {return self._payload != nil}
  /// Clears the value of `payload`. Subsequent reads from it will return its default value.
  public mutating func clearPayload() {self._payload = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Payload {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var sample: Data = Data()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _accelSettings: IMU_Accel_Settings? = nil
  fileprivate var _gyroSettings: IMU_Gyro_Settings? = nil
  fileprivate var _payload: IMUPacket.Payload? = nil
}

public struct MicPacket {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var packetIndex: UInt32 = 0

  public var samplePeriod: UInt32 = 0

  public var micSampleFreq: UInt32 = 0

  public var samplesPerFft: UInt32 = 0

  public var startFrequency: Float = 0

  public var frequencySpacing: Float = 0

  public var payload: MicPacket.Payload {
    get {return _payload ?? MicPacket.Payload()}
    set {_payload = newValue}
  }
  /// Returns true if `payload` has been explicitly set.
  public var hasPayload: Bool {return self._payload != nil}
  /// Clears the value of `payload`. Subsequent reads from it will return its default value.
  public mutating func clearPayload() {self._payload = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Payload {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var sample: [Float] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _payload: MicPacket.Payload? = nil
}

public struct AirSpecColors {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var red: UInt32 = 0

  public var green: UInt32 = 0

  public var blue: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct AirSpecColorPosition {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var forward: AirSpecColors {
    get {return _forward ?? AirSpecColors()}
    set {_forward = newValue}
  }
  /// Returns true if `forward` has been explicitly set.
  public var hasForward: Bool {return self._forward != nil}
  /// Clears the value of `forward`. Subsequent reads from it will return its default value.
  public mutating func clearForward() {self._forward = nil}

  public var eye: AirSpecColors {
    get {return _eye ?? AirSpecColors()}
    set {_eye = newValue}
  }
  /// Returns true if `eye` has been explicitly set.
  public var hasEye: Bool {return self._eye != nil}
  /// Clears the value of `eye`. Subsequent reads from it will return its default value.
  public mutating func clearEye() {self._eye = nil}

  public var top: AirSpecColors {
    get {return _top ?? AirSpecColors()}
    set {_top = newValue}
  }
  /// Returns true if `top` has been explicitly set.
  public var hasTop: Bool {return self._top != nil}
  /// Clears the value of `top`. Subsequent reads from it will return its default value.
  public mutating func clearTop() {self._top = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _forward: AirSpecColors? = nil
  fileprivate var _eye: AirSpecColors? = nil
  fileprivate var _top: AirSpecColors? = nil
}

public struct LightControlPacket {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var left: AirSpecColorPosition {
    get {return _storage._left ?? AirSpecColorPosition()}
    set {_uniqueStorage()._left = newValue}
  }
  /// Returns true if `left` has been explicitly set.
  public var hasLeft: Bool {return _storage._left != nil}
  /// Clears the value of `left`. Subsequent reads from it will return its default value.
  public mutating func clearLeft() {_uniqueStorage()._left = nil}

  public var right: AirSpecColorPosition {
    get {return _storage._right ?? AirSpecColorPosition()}
    set {_uniqueStorage()._right = newValue}
  }
  /// Returns true if `right` has been explicitly set.
  public var hasRight: Bool {return _storage._right != nil}
  /// Clears the value of `right`. Subsequent reads from it will return its default value.
  public mutating func clearRight() {_uniqueStorage()._right = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct SensorControl {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var enableAll: Bool = false

  public var spectrometer: Bool = false

  public var bme688: Bool = false

  public var imu: Bool = false

  public var thermopiles: Bool = false

  public var lux: Bool = false

  public var mic: Bool = false

  public var sht: Bool = false

  public var sgp: Bool = false

  public var blink: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct LuxSensorConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var samplePeriodMs: UInt32 = 0

  public var gain: Tsl2591Gain = .tsl2722Gain1X

  public var integrationTime: Tsl2591IntegrationTime = .tsl2722Integrationtime600Ms

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct SGP_Sensor_Config {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var samplePeriodMs: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct BME_Sensor_Config {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var samplePeriodMs: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ColorSensorConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var samplePeriodMs: UInt32 = 0

  public var integrationTime: UInt32 = 0

  public var integrationStep: UInt32 = 0

  public var gain: Spec_gain = .gain05X

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ThermopileSensorConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var samplePeriodMs: UInt32 = 0

  public var enableTopOfNose: Bool = false

  public var enableNoseBridge: Bool = false

  public var enableFrontTemple: Bool = false

  public var enableMidTemple: Bool = false

  public var enableRearTemple: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct BlinkSensorConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sampleFrequency: UInt32 = 0

  public var enableDaylightCompensation: Bool = false

  public var daylightCompensationUpperThresh: UInt32 = 0

  public var daylightCompensationLowerThresh: UInt32 = 0

  public var enableWindowing: UInt32 = 0

  public var windowSizeMs: UInt32 = 0

  public var windowPeriodMs: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MicSensorConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var samplePeriodMs: UInt32 = 0

  public var micSampleFreq: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct HumiditySensorConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var samplePeriodMs: UInt32 = 0

  public var precisionLevel: Sht45_precision = .sht4XHighPrecision

  public var heaterSettings: Sht45_heater = .sht4XNoHeater

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct IMU_SensorConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var accelSettings: IMU_Accel_Settings {
    get {return _accelSettings ?? IMU_Accel_Settings()}
    set {_accelSettings = newValue}
  }
  /// Returns true if `accelSettings` has been explicitly set.
  public var hasAccelSettings: Bool {return self._accelSettings != nil}
  /// Clears the value of `accelSettings`. Subsequent reads from it will return its default value.
  public mutating func clearAccelSettings() {self._accelSettings = nil}

  public var gyroSettings: IMU_Gyro_Settings {
    get {return _gyroSettings ?? IMU_Gyro_Settings()}
    set {_gyroSettings = newValue}
  }
  /// Returns true if `gyroSettings` has been explicitly set.
  public var hasGyroSettings: Bool {return self._gyroSettings != nil}
  /// Clears the value of `gyroSettings`. Subsequent reads from it will return its default value.
  public mutating func clearGyroSettings() {self._gyroSettings = nil}

  public var enableWindowing: UInt32 = 0

  public var windowSizeMs: UInt32 = 0

  public var windowPeriodMs: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _accelSettings: IMU_Accel_Settings? = nil
  fileprivate var _gyroSettings: IMU_Gyro_Settings? = nil
}

public struct SensorConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var lux: LuxSensorConfig {
    get {return _storage._lux ?? LuxSensorConfig()}
    set {_uniqueStorage()._lux = newValue}
  }
  /// Returns true if `lux` has been explicitly set.
  public var hasLux: Bool {return _storage._lux != nil}
  /// Clears the value of `lux`. Subsequent reads from it will return its default value.
  public mutating func clearLux() {_uniqueStorage()._lux = nil}

  public var sgp: SGP_Sensor_Config {
    get {return _storage._sgp ?? SGP_Sensor_Config()}
    set {_uniqueStorage()._sgp = newValue}
  }
  /// Returns true if `sgp` has been explicitly set.
  public var hasSgp: Bool {return _storage._sgp != nil}
  /// Clears the value of `sgp`. Subsequent reads from it will return its default value.
  public mutating func clearSgp() {_uniqueStorage()._sgp = nil}

  public var bme: BME_Sensor_Config {
    get {return _storage._bme ?? BME_Sensor_Config()}
    set {_uniqueStorage()._bme = newValue}
  }
  /// Returns true if `bme` has been explicitly set.
  public var hasBme: Bool {return _storage._bme != nil}
  /// Clears the value of `bme`. Subsequent reads from it will return its default value.
  public mutating func clearBme() {_uniqueStorage()._bme = nil}

  public var color: ColorSensorConfig {
    get {return _storage._color ?? ColorSensorConfig()}
    set {_uniqueStorage()._color = newValue}
  }
  /// Returns true if `color` has been explicitly set.
  public var hasColor: Bool {return _storage._color != nil}
  /// Clears the value of `color`. Subsequent reads from it will return its default value.
  public mutating func clearColor() {_uniqueStorage()._color = nil}

  public var thermopile: ThermopileSensorConfig {
    get {return _storage._thermopile ?? ThermopileSensorConfig()}
    set {_uniqueStorage()._thermopile = newValue}
  }
  /// Returns true if `thermopile` has been explicitly set.
  public var hasThermopile: Bool {return _storage._thermopile != nil}
  /// Clears the value of `thermopile`. Subsequent reads from it will return its default value.
  public mutating func clearThermopile() {_uniqueStorage()._thermopile = nil}

  public var blink: BlinkSensorConfig {
    get {return _storage._blink ?? BlinkSensorConfig()}
    set {_uniqueStorage()._blink = newValue}
  }
  /// Returns true if `blink` has been explicitly set.
  public var hasBlink: Bool {return _storage._blink != nil}
  /// Clears the value of `blink`. Subsequent reads from it will return its default value.
  public mutating func clearBlink() {_uniqueStorage()._blink = nil}

  public var mic: MicSensorConfig {
    get {return _storage._mic ?? MicSensorConfig()}
    set {_uniqueStorage()._mic = newValue}
  }
  /// Returns true if `mic` has been explicitly set.
  public var hasMic: Bool {return _storage._mic != nil}
  /// Clears the value of `mic`. Subsequent reads from it will return its default value.
  public mutating func clearMic() {_uniqueStorage()._mic = nil}

  public var humidity: HumiditySensorConfig {
    get {return _storage._humidity ?? HumiditySensorConfig()}
    set {_uniqueStorage()._humidity = newValue}
  }
  /// Returns true if `humidity` has been explicitly set.
  public var hasHumidity: Bool {return _storage._humidity != nil}
  /// Clears the value of `humidity`. Subsequent reads from it will return its default value.
  public mutating func clearHumidity() {_uniqueStorage()._humidity = nil}

  public var imu: IMU_SensorConfig {
    get {return _storage._imu ?? IMU_SensorConfig()}
    set {_uniqueStorage()._imu = newValue}
  }
  /// Returns true if `imu` has been explicitly set.
  public var hasImu: Bool {return _storage._imu != nil}
  /// Clears the value of `imu`. Subsequent reads from it will return its default value.
  public mutating func clearImu() {_uniqueStorage()._imu = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct DFU_Mode {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var enable: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct BlueGreenTransition {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var enable: Bool = false

  public var blueMinIntensity: UInt32 = 0

  public var blueMaxIntensity: UInt32 = 0

  public var greenMaxIntensity: UInt32 = 0

  public var stepSize: UInt32 = 0

  public var stepDurationMs: UInt32 = 0

  public var greenHoldLengthSeconds: UInt32 = 0

  public var transitionDelaySeconds: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct RedFlashTask {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var enable: Bool = false

  public var redMaxIntensity: UInt32 = 0

  public var redMinIntensity: UInt32 = 0

  public var frequency: UInt32 = 0

  public var durationMs: UInt32 = 0

  public var enableSpeaker: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct AirSpecConfigHeader {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var timestampUnix: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct AirSpecConfigPacket {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var header: AirSpecConfigHeader {
    get {return _header ?? AirSpecConfigHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  public var payload: AirSpecConfigPacket.OneOf_Payload? = nil

  public var ctrlIndivLed: LightControlPacket {
    get {
      if case .ctrlIndivLed(let v)? = payload {return v}
      return LightControlPacket()
    }
    set {payload = .ctrlIndivLed(newValue)}
  }

  public var sensorControl: SensorControl {
    get {
      if case .sensorControl(let v)? = payload {return v}
      return SensorControl()
    }
    set {payload = .sensorControl(newValue)}
  }

  public var sensorConfig: SensorConfig {
    get {
      if case .sensorConfig(let v)? = payload {return v}
      return SensorConfig()
    }
    set {payload = .sensorConfig(newValue)}
  }

  public var dfuMode: DFU_Mode {
    get {
      if case .dfuMode(let v)? = payload {return v}
      return DFU_Mode()
    }
    set {payload = .dfuMode(newValue)}
  }

  public var blueGreenTransition: BlueGreenTransition {
    get {
      if case .blueGreenTransition(let v)? = payload {return v}
      return BlueGreenTransition()
    }
    set {payload = .blueGreenTransition(newValue)}
  }

  public var redFlashTask: RedFlashTask {
    get {
      if case .redFlashTask(let v)? = payload {return v}
      return RedFlashTask()
    }
    set {payload = .redFlashTask(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    case ctrlIndivLed(LightControlPacket)
    case sensorControl(SensorControl)
    case sensorConfig(SensorConfig)
    case dfuMode(DFU_Mode)
    case blueGreenTransition(BlueGreenTransition)
    case redFlashTask(RedFlashTask)

  #if !swift(>=4.1)
    public static func ==(lhs: AirSpecConfigPacket.OneOf_Payload, rhs: AirSpecConfigPacket.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.ctrlIndivLed, .ctrlIndivLed): return {
        guard case .ctrlIndivLed(let l) = lhs, case .ctrlIndivLed(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sensorControl, .sensorControl): return {
        guard case .sensorControl(let l) = lhs, case .sensorControl(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sensorConfig, .sensorConfig): return {
        guard case .sensorConfig(let l) = lhs, case .sensorConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.dfuMode, .dfuMode): return {
        guard case .dfuMode(let l) = lhs, case .dfuMode(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.blueGreenTransition, .blueGreenTransition): return {
        guard case .blueGreenTransition(let l) = lhs, case .blueGreenTransition(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.redFlashTask, .redFlashTask): return {
        guard case .redFlashTask(let l) = lhs, case .redFlashTask(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _header: AirSpecConfigHeader? = nil
}

public struct systemState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var firmwareVersion: UInt32 = 0

  public var control: SensorControl {
    get {return _control ?? SensorControl()}
    set {_control = newValue}
  }
  /// Returns true if `control` has been explicitly set.
  public var hasControl: Bool {return self._control != nil}
  /// Clears the value of `control`. Subsequent reads from it will return its default value.
  public mutating func clearControl() {self._control = nil}

  public var config: SensorConfig {
    get {return _config ?? SensorConfig()}
    set {_config = newValue}
  }
  /// Returns true if `config` has been explicitly set.
  public var hasConfig: Bool {return self._config != nil}
  /// Clears the value of `config`. Subsequent reads from it will return its default value.
  public mutating func clearConfig() {self._config = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _control: SensorControl? = nil
  fileprivate var _config: SensorConfig? = nil
}

public struct appSurveyDataPayload {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var qIndex: Int32 = 0

  public var qChoice: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct appSurveyDataPacket {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uidPhone: UInt32 = 0 /// iphone unique identifier

  public var payload: [appSurveyDataPayload] = [] /// set of (qIndex, qChoice)

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct appMetaDataPacket {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uidPhone: UInt32 = 0

  public var payload: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct SensorPacket {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var header: SensorPacketHeader {
    get {return _header ?? SensorPacketHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  public var payload: SensorPacket.OneOf_Payload? = nil

  public var luxPacket: LuxPacket {
    get {
      if case .luxPacket(let v)? = payload {return v}
      return LuxPacket()
    }
    set {payload = .luxPacket(newValue)}
  }

  public var sgpPacket: SGPPacket {
    get {
      if case .sgpPacket(let v)? = payload {return v}
      return SGPPacket()
    }
    set {payload = .sgpPacket(newValue)}
  }

  public var bmePacket: BMEPacket {
    get {
      if case .bmePacket(let v)? = payload {return v}
      return BMEPacket()
    }
    set {payload = .bmePacket(newValue)}
  }

  public var blinkPacket: BlinkPacket {
    get {
      if case .blinkPacket(let v)? = payload {return v}
      return BlinkPacket()
    }
    set {payload = .blinkPacket(newValue)}
  }

  public var shtPacket: SHTPacket {
    get {
      if case .shtPacket(let v)? = payload {return v}
      return SHTPacket()
    }
    set {payload = .shtPacket(newValue)}
  }

  public var specPacket: SpecPacket {
    get {
      if case .specPacket(let v)? = payload {return v}
      return SpecPacket()
    }
    set {payload = .specPacket(newValue)}
  }

  public var thermPacket: ThermPacket {
    get {
      if case .thermPacket(let v)? = payload {return v}
      return ThermPacket()
    }
    set {payload = .thermPacket(newValue)}
  }

  public var imuPacket: IMUPacket {
    get {
      if case .imuPacket(let v)? = payload {return v}
      return IMUPacket()
    }
    set {payload = .imuPacket(newValue)}
  }

  public var micPacket: MicPacket {
    get {
      if case .micPacket(let v)? = payload {return v}
      return MicPacket()
    }
    set {payload = .micPacket(newValue)}
  }

  public var surveyPacket: appSurveyDataPacket {
    get {
      if case .surveyPacket(let v)? = payload {return v}
      return appSurveyDataPacket()
    }
    set {payload = .surveyPacket(newValue)}
  }

  public var metaDataPacket: appMetaDataPacket {
    get {
      if case .metaDataPacket(let v)? = payload {return v}
      return appMetaDataPacket()
    }
    set {payload = .metaDataPacket(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    case luxPacket(LuxPacket)
    case sgpPacket(SGPPacket)
    case bmePacket(BMEPacket)
    case blinkPacket(BlinkPacket)
    case shtPacket(SHTPacket)
    case specPacket(SpecPacket)
    case thermPacket(ThermPacket)
    case imuPacket(IMUPacket)
    case micPacket(MicPacket)
    case surveyPacket(appSurveyDataPacket)
    case metaDataPacket(appMetaDataPacket)

  #if !swift(>=4.1)
    public static func ==(lhs: SensorPacket.OneOf_Payload, rhs: SensorPacket.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.luxPacket, .luxPacket): return {
        guard case .luxPacket(let l) = lhs, case .luxPacket(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sgpPacket, .sgpPacket): return {
        guard case .sgpPacket(let l) = lhs, case .sgpPacket(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.bmePacket, .bmePacket): return {
        guard case .bmePacket(let l) = lhs, case .bmePacket(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.blinkPacket, .blinkPacket): return {
        guard case .blinkPacket(let l) = lhs, case .blinkPacket(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.shtPacket, .shtPacket): return {
        guard case .shtPacket(let l) = lhs, case .shtPacket(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.specPacket, .specPacket): return {
        guard case .specPacket(let l) = lhs, case .specPacket(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.thermPacket, .thermPacket): return {
        guard case .thermPacket(let l) = lhs, case .thermPacket(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.imuPacket, .imuPacket): return {
        guard case .imuPacket(let l) = lhs, case .imuPacket(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.micPacket, .micPacket): return {
        guard case .micPacket(let l) = lhs, case .micPacket(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.surveyPacket, .surveyPacket): return {
        guard case .surveyPacket(let l) = lhs, case .surveyPacket(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.metaDataPacket, .metaDataPacket): return {
        guard case .metaDataPacket(let l) = lhs, case .metaDataPacket(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _header: SensorPacketHeader? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension SensorPacketTypes: @unchecked Sendable {}
extension Tsl2591Gain: @unchecked Sendable {}
extension Tsl2591IntegrationTime: @unchecked Sendable {}
extension Sht45_precision: @unchecked Sendable {}
extension Sht45_heater: @unchecked Sendable {}
extension Thermopile_location: @unchecked Sendable {}
extension BME680_accuracy: @unchecked Sendable {}
extension BME680_signal_id: @unchecked Sendable {}
extension Spec_gain: @unchecked Sendable {}
extension IMU_gyro_cutoff: @unchecked Sendable {}
extension IMU_gyro_range: @unchecked Sendable {}
extension IMU_accel_cutoff: @unchecked Sendable {}
extension IMU_accel_range: @unchecked Sendable {}
extension IMU_mag_cutoff: @unchecked Sendable {}
extension SensorPacketHeader: @unchecked Sendable {}
extension LuxPacket: @unchecked Sendable {}
extension LuxPacket.Payload: @unchecked Sendable {}
extension SGPPacket: @unchecked Sendable {}
extension SGPPacket.Payload: @unchecked Sendable {}
extension BMEPacket: @unchecked Sendable {}
extension BMEPacket.Payload: @unchecked Sendable {}
extension Blink_saturation_settings: @unchecked Sendable {}
extension BlinkBytePayload: @unchecked Sendable {}
extension BlinkHighResPayload: @unchecked Sendable {}
extension BlinkPacket: @unchecked Sendable {}
extension BlinkPacket.OneOf_Payload: @unchecked Sendable {}
extension SHTPacket: @unchecked Sendable {}
extension SHTPacket.Payload: @unchecked Sendable {}
extension SpecPacket: @unchecked Sendable {}
extension SpecPacket.Payload: @unchecked Sendable {}
extension ThermPacket: @unchecked Sendable {}
extension ThermPacket.Payload: @unchecked Sendable {}
extension IMU_Accel_Settings: @unchecked Sendable {}
extension IMU_Gyro_Settings: @unchecked Sendable {}
extension IMUPacket: @unchecked Sendable {}
extension IMUPacket.Payload: @unchecked Sendable {}
extension MicPacket: @unchecked Sendable {}
extension MicPacket.Payload: @unchecked Sendable {}
extension AirSpecColors: @unchecked Sendable {}
extension AirSpecColorPosition: @unchecked Sendable {}
extension LightControlPacket: @unchecked Sendable {}
extension SensorControl: @unchecked Sendable {}
extension LuxSensorConfig: @unchecked Sendable {}
extension SGP_Sensor_Config: @unchecked Sendable {}
extension BME_Sensor_Config: @unchecked Sendable {}
extension ColorSensorConfig: @unchecked Sendable {}
extension ThermopileSensorConfig: @unchecked Sendable {}
extension BlinkSensorConfig: @unchecked Sendable {}
extension MicSensorConfig: @unchecked Sendable {}
extension HumiditySensorConfig: @unchecked Sendable {}
extension IMU_SensorConfig: @unchecked Sendable {}
extension SensorConfig: @unchecked Sendable {}
extension DFU_Mode: @unchecked Sendable {}
extension BlueGreenTransition: @unchecked Sendable {}
extension RedFlashTask: @unchecked Sendable {}
extension AirSpecConfigHeader: @unchecked Sendable {}
extension AirSpecConfigPacket: @unchecked Sendable {}
extension AirSpecConfigPacket.OneOf_Payload: @unchecked Sendable {}
extension systemState: @unchecked Sendable {}
extension appSurveyDataPayload: @unchecked Sendable {}
extension appSurveyDataPacket: @unchecked Sendable {}
extension appMetaDataPacket: @unchecked Sendable {}
extension SensorPacket: @unchecked Sendable {}
extension SensorPacket.OneOf_Payload: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension SensorPacketTypes: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_PACKET_TYPE"),
    1: .same(proto: "PPG_RED"),
    2: .same(proto: "PPG_IR"),
    3: .same(proto: "SPECTROMETER"),
    4: .same(proto: "BME"),
    5: .same(proto: "CO2"),
    6: .same(proto: "IMU"),
    7: .same(proto: "THERMOPILE"),
    8: .same(proto: "LUX"),
    9: .same(proto: "LIDAR"),
    10: .same(proto: "MIC"),
    11: .same(proto: "SHT"),
    12: .same(proto: "SGP"),
    13: .same(proto: "BLINK"),
  ]
}

extension Tsl2591Gain: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TSL2722_GAIN_1X"),
    1: .same(proto: "TSL2722_GAIN_8X"),
    2: .same(proto: "TSL2722_GAIN_16X"),
    3: .same(proto: "TSL2722_GAIN_120X"),
  ]
}

extension Tsl2591IntegrationTime: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TSL2722_INTEGRATIONTIME_600MS"),
    192: .same(proto: "TSL2722_INTEGRATIONTIME_175MS"),
    219: .same(proto: "TSL2722_INTEGRATIONTIME_101MS"),
    246: .same(proto: "TSL2722_INTEGRATIONTIME_27_30MS"),
    255: .same(proto: "TSL2722_INTEGRATIONTIME_2_73MS"),
  ]
}

extension Sht45_precision: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SHT4X_HIGH_PRECISION"),
    1: .same(proto: "SHT4X_MED_PRECISION"),
    2: .same(proto: "SHT4X_LOW_PRECISION"),
  ]
}

extension Sht45_heater: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SHT4X_NO_HEATER"),
    1: .same(proto: "SHT4X_HIGH_HEATER_1S"),
    2: .same(proto: "SHT4X_HIGH_HEATER_100MS"),
    3: .same(proto: "SHT4X_MED_HEATER_1S"),
    4: .same(proto: "SHT4X_MED_HEATER_100MS"),
    5: .same(proto: "SHT4X_LOW_HEATER_1S"),
    6: .same(proto: "SHT4X_LOW_HEATER_100MS"),
  ]
}

extension Thermopile_location: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TIP_OF_NOSE"),
    1: .same(proto: "NOSE_BRIDGE"),
    2: .same(proto: "FRONT_TEMPLE"),
    3: .same(proto: "MID_TEMPLE"),
    4: .same(proto: "REAR_TEMPLE"),
  ]
}

extension BME680_accuracy: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNRELIABLE"),
    1: .same(proto: "LOW_ACCURACY"),
    2: .same(proto: "MEDIUM_ACCURACY"),
    3: .same(proto: "HIGH_ACCURACY"),
  ]
}

extension BME680_signal_id: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNDEFINED"),
    1: .same(proto: "IAQ"),
    2: .same(proto: "STATIC_IAQ"),
    3: .same(proto: "CO2_EQ"),
    4: .same(proto: "BREATH_VOC_EQ"),
    6: .same(proto: "RAW_TEMPERATURE"),
    7: .same(proto: "RAW_PRESSURE"),
    8: .same(proto: "RAW_HUMIDITY"),
    9: .same(proto: "RAW_GAS"),
    12: .same(proto: "STABILIZATION_STATUS"),
    13: .same(proto: "RUN_IN_STATUS"),
    14: .same(proto: "SENSOR_HEAT_COMPEN_TEMP"),
    15: .same(proto: "HEAT_COMPEN_HUMID"),
    21: .same(proto: "GAS_PERCENTAGE"),
  ]
}

extension Spec_gain: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "GAIN_0_5X"),
    1: .same(proto: "GAIN_1X"),
    2: .same(proto: "GAIN_2X"),
    3: .same(proto: "GAIN_4X"),
    4: .same(proto: "GAIN_8X"),
    5: .same(proto: "GAIN_16X"),
    6: .same(proto: "GAIN_32X"),
    7: .same(proto: "GAIN_64X"),
    8: .same(proto: "GAIN_128X"),
    9: .same(proto: "GAIN_256X"),
    10: .same(proto: "GAIN_512X"),
  ]
}

extension IMU_gyro_cutoff: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ICM20X_GYRO_FREQ_196_6_HZ"),
    1: .same(proto: "ICM20X_GYRO_FREQ_151_8_HZ"),
    2: .same(proto: "ICM20X_GYRO_FREQ_119_5_HZ"),
    3: .same(proto: "ICM20X_GYRO_FREQ_51_2_HZ"),
    4: .same(proto: "ICM20X_GYRO_FREQ_23_9_HZ"),
    5: .same(proto: "ICM20X_GYRO_FREQ_11_6_HZ"),
    6: .same(proto: "ICM20X_GYRO_FREQ_5_7_HZ"),
    7: .same(proto: "ICM20X_GYRO_FREQ_361_4_HZ"),
  ]
}

extension IMU_gyro_range: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RANGE_250_dps"),
    1: .same(proto: "RANGE_500_dps"),
    2: .same(proto: "RANGE_1000_dps"),
    3: .same(proto: "RANGE_2000_dps"),
  ]
}

extension IMU_accel_cutoff: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNDEFINED_ACCEL_CUTOFF"),
    1: .same(proto: "ICM20X_ACCEL_FREQ_246_0_HZ"),
    2: .same(proto: "ICM20X_ACCEL_FREQ_111_4_HZ"),
    3: .same(proto: "ICM20X_ACCEL_FREQ_50_4_HZ"),
    4: .same(proto: "ICM20X_ACCEL_FREQ_23_9_HZ"),
    5: .same(proto: "ICM20X_ACCEL_FREQ_11_5_HZ"),
    6: .same(proto: "ICM20X_ACCEL_FREQ_5_7_HZ"),
    7: .same(proto: "ICM20X_ACCEL_FREQ_473_HZ"),
  ]
}

extension IMU_accel_range: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RANGE_2G"),
    1: .same(proto: "RANGE_4G"),
    2: .same(proto: "RANGE_8G"),
    3: .same(proto: "RANGE_16G"),
  ]
}

extension IMU_mag_cutoff: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNDEFINED_MAG_CUTOFF"),
    2: .same(proto: "ICM20X_MAG_10_HZ"),
    4: .same(proto: "ICM20X_MAG_20_HZ"),
    6: .same(proto: "ICM20X_MAG_50_HZ"),
    8: .same(proto: "ICM20X_MAG_100_HZ"),
  ]
}

extension SensorPacketHeader: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SensorPacketHeader"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "system_uid"),
    2: .standard(proto: "ms_from_start"),
    3: .same(proto: "epoch"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.systemUid) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.msFromStart) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.epoch) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.systemUid != 0 {
      try visitor.visitSingularUInt32Field(value: self.systemUid, fieldNumber: 1)
    }
    if self.msFromStart != 0 {
      try visitor.visitSingularUInt32Field(value: self.msFromStart, fieldNumber: 2)
    }
    if self.epoch != 0 {
      try visitor.visitSingularUInt32Field(value: self.epoch, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SensorPacketHeader, rhs: SensorPacketHeader) -> Bool {
    if lhs.systemUid != rhs.systemUid {return false}
    if lhs.msFromStart != rhs.msFromStart {return false}
    if lhs.epoch != rhs.epoch {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LuxPacket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "LuxPacket"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "packet_index"),
    2: .standard(proto: "sample_period"),
    3: .same(proto: "gain"),
    4: .standard(proto: "integration_time"),
    5: .same(proto: "payload"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.packetIndex) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.samplePeriod) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.gain) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.integrationTime) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.payload) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.packetIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.packetIndex, fieldNumber: 1)
    }
    if self.samplePeriod != 0 {
      try visitor.visitSingularUInt32Field(value: self.samplePeriod, fieldNumber: 2)
    }
    if self.gain != .tsl2722Gain1X {
      try visitor.visitSingularEnumField(value: self.gain, fieldNumber: 3)
    }
    if self.integrationTime != .tsl2722Integrationtime600Ms {
      try visitor.visitSingularEnumField(value: self.integrationTime, fieldNumber: 4)
    }
    if !self.payload.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.payload, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: LuxPacket, rhs: LuxPacket) -> Bool {
    if lhs.packetIndex != rhs.packetIndex {return false}
    if lhs.samplePeriod != rhs.samplePeriod {return false}
    if lhs.gain != rhs.gain {return false}
    if lhs.integrationTime != rhs.integrationTime {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LuxPacket.Payload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = LuxPacket.protoMessageName + ".Payload"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "lux"),
    2: .standard(proto: "timestamp_unix"),
    3: .standard(proto: "timestamp_ms_from_start"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.lux) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.timestampUnix) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.timestampMsFromStart) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.lux != 0 {
      try visitor.visitSingularUInt32Field(value: self.lux, fieldNumber: 1)
    }
    if self.timestampUnix != 0 {
      try visitor.visitSingularUInt32Field(value: self.timestampUnix, fieldNumber: 2)
    }
    if self.timestampMsFromStart != 0 {
      try visitor.visitSingularUInt32Field(value: self.timestampMsFromStart, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: LuxPacket.Payload, rhs: LuxPacket.Payload) -> Bool {
    if lhs.lux != rhs.lux {return false}
    if lhs.timestampUnix != rhs.timestampUnix {return false}
    if lhs.timestampMsFromStart != rhs.timestampMsFromStart {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SGPPacket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SGPPacket"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "packet_index"),
    2: .standard(proto: "sample_period"),
    3: .same(proto: "payload"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.packetIndex) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.samplePeriod) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.payload) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.packetIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.packetIndex, fieldNumber: 1)
    }
    if self.samplePeriod != 0 {
      try visitor.visitSingularUInt32Field(value: self.samplePeriod, fieldNumber: 2)
    }
    if !self.payload.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.payload, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SGPPacket, rhs: SGPPacket) -> Bool {
    if lhs.packetIndex != rhs.packetIndex {return false}
    if lhs.samplePeriod != rhs.samplePeriod {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SGPPacket.Payload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = SGPPacket.protoMessageName + ".Payload"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "timestamp_unix"),
    2: .standard(proto: "timestamp_ms_from_start"),
    3: .standard(proto: "sraw_voc"),
    4: .standard(proto: "sraw_nox"),
    5: .standard(proto: "voc_index_value"),
    6: .standard(proto: "nox_index_value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.timestampUnix) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.timestampMsFromStart) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.srawVoc) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.srawNox) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.vocIndexValue) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.noxIndexValue) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.timestampUnix != 0 {
      try visitor.visitSingularUInt32Field(value: self.timestampUnix, fieldNumber: 1)
    }
    if self.timestampMsFromStart != 0 {
      try visitor.visitSingularUInt32Field(value: self.timestampMsFromStart, fieldNumber: 2)
    }
    if self.srawVoc != 0 {
      try visitor.visitSingularUInt32Field(value: self.srawVoc, fieldNumber: 3)
    }
    if self.srawNox != 0 {
      try visitor.visitSingularUInt32Field(value: self.srawNox, fieldNumber: 4)
    }
    if self.vocIndexValue != 0 {
      try visitor.visitSingularInt32Field(value: self.vocIndexValue, fieldNumber: 5)
    }
    if self.noxIndexValue != 0 {
      try visitor.visitSingularInt32Field(value: self.noxIndexValue, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SGPPacket.Payload, rhs: SGPPacket.Payload) -> Bool {
    if lhs.timestampUnix != rhs.timestampUnix {return false}
    if lhs.timestampMsFromStart != rhs.timestampMsFromStart {return false}
    if lhs.srawVoc != rhs.srawVoc {return false}
    if lhs.srawNox != rhs.srawNox {return false}
    if lhs.vocIndexValue != rhs.vocIndexValue {return false}
    if lhs.noxIndexValue != rhs.noxIndexValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BMEPacket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "BMEPacket"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "packet_index"),
    2: .standard(proto: "sample_period"),
    3: .same(proto: "payload"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.packetIndex) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.samplePeriod) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.payload) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.packetIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.packetIndex, fieldNumber: 1)
    }
    if self.samplePeriod != 0 {
      try visitor.visitSingularUInt32Field(value: self.samplePeriod, fieldNumber: 2)
    }
    if !self.payload.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.payload, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BMEPacket, rhs: BMEPacket) -> Bool {
    if lhs.packetIndex != rhs.packetIndex {return false}
    if lhs.samplePeriod != rhs.samplePeriod {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BMEPacket.Payload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BMEPacket.protoMessageName + ".Payload"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "timestamp_sensor"),
    2: .standard(proto: "timestamp_unix"),
    3: .standard(proto: "timestamp_ms_from_start"),
    4: .same(proto: "signal"),
    5: .standard(proto: "signal_dimensions"),
    6: .standard(proto: "sensor_id"),
    7: .same(proto: "accuracy"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed64Field(value: &self.timestampSensor) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.timestampUnix) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.timestampMsFromStart) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.signal) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.signalDimensions) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.sensorID) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.accuracy) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.timestampSensor != 0 {
      try visitor.visitSingularFixed64Field(value: self.timestampSensor, fieldNumber: 1)
    }
    if self.timestampUnix != 0 {
      try visitor.visitSingularUInt32Field(value: self.timestampUnix, fieldNumber: 2)
    }
    if self.timestampMsFromStart != 0 {
      try visitor.visitSingularUInt32Field(value: self.timestampMsFromStart, fieldNumber: 3)
    }
    if self.signal != 0 {
      try visitor.visitSingularFloatField(value: self.signal, fieldNumber: 4)
    }
    if self.signalDimensions != 0 {
      try visitor.visitSingularUInt32Field(value: self.signalDimensions, fieldNumber: 5)
    }
    if self.sensorID != .undefined {
      try visitor.visitSingularEnumField(value: self.sensorID, fieldNumber: 6)
    }
    if self.accuracy != .unreliable {
      try visitor.visitSingularEnumField(value: self.accuracy, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BMEPacket.Payload, rhs: BMEPacket.Payload) -> Bool {
    if lhs.timestampSensor != rhs.timestampSensor {return false}
    if lhs.timestampUnix != rhs.timestampUnix {return false}
    if lhs.timestampMsFromStart != rhs.timestampMsFromStart {return false}
    if lhs.signal != rhs.signal {return false}
    if lhs.signalDimensions != rhs.signalDimensions {return false}
    if lhs.sensorID != rhs.sensorID {return false}
    if lhs.accuracy != rhs.accuracy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Blink_saturation_settings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Blink_saturation_settings"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "diode_turned_off"),
    2: .standard(proto: "diode_saturation_lower_thresh"),
    3: .standard(proto: "diode_saturation_upper_thresh"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.diodeTurnedOff) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.diodeSaturationLowerThresh) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.diodeSaturationUpperThresh) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.diodeTurnedOff != false {
      try visitor.visitSingularBoolField(value: self.diodeTurnedOff, fieldNumber: 1)
    }
    if self.diodeSaturationLowerThresh != 0 {
      try visitor.visitSingularUInt32Field(value: self.diodeSaturationLowerThresh, fieldNumber: 2)
    }
    if self.diodeSaturationUpperThresh != 0 {
      try visitor.visitSingularUInt32Field(value: self.diodeSaturationUpperThresh, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Blink_saturation_settings, rhs: Blink_saturation_settings) -> Bool {
    if lhs.diodeTurnedOff != rhs.diodeTurnedOff {return false}
    if lhs.diodeSaturationLowerThresh != rhs.diodeSaturationLowerThresh {return false}
    if lhs.diodeSaturationUpperThresh != rhs.diodeSaturationUpperThresh {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BlinkBytePayload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "BlinkBytePayload"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sample"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.sample) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sample.isEmpty {
      try visitor.visitSingularBytesField(value: self.sample, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BlinkBytePayload, rhs: BlinkBytePayload) -> Bool {
    if lhs.sample != rhs.sample {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BlinkHighResPayload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "BlinkHighResPayload"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sample"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.sample) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sample.isEmpty {
      try visitor.visitSingularBytesField(value: self.sample, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BlinkHighResPayload, rhs: BlinkHighResPayload) -> Bool {
    if lhs.sample != rhs.sample {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BlinkPacket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "BlinkPacket"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "packet_index"),
    2: .standard(proto: "saturation_settings"),
    3: .standard(proto: "sample_rate"),
    4: .same(proto: "payloadByte"),
    5: .same(proto: "payloadHighRes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.packetIndex) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._saturationSettings) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.sampleRate) }()
      case 4: try {
        var v: BlinkBytePayload?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .payloadByte(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .payloadByte(v)
        }
      }()
      case 5: try {
        var v: BlinkHighResPayload?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .payloadHighRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .payloadHighRes(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.packetIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.packetIndex, fieldNumber: 1)
    }
    try { if let v = self._saturationSettings {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.sampleRate != 0 {
      try visitor.visitSingularUInt32Field(value: self.sampleRate, fieldNumber: 3)
    }
    switch self.payload {
    case .payloadByte?: try {
      guard case .payloadByte(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .payloadHighRes?: try {
      guard case .payloadHighRes(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BlinkPacket, rhs: BlinkPacket) -> Bool {
    if lhs.packetIndex != rhs.packetIndex {return false}
    if lhs._saturationSettings != rhs._saturationSettings {return false}
    if lhs.sampleRate != rhs.sampleRate {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SHTPacket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SHTPacket"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "packet_index"),
    2: .standard(proto: "sample_period"),
    3: .same(proto: "precision"),
    4: .same(proto: "heater"),
    5: .same(proto: "payload"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.packetIndex) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.samplePeriod) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.precision) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.heater) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.payload) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.packetIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.packetIndex, fieldNumber: 1)
    }
    if self.samplePeriod != 0 {
      try visitor.visitSingularUInt32Field(value: self.samplePeriod, fieldNumber: 2)
    }
    if self.precision != .sht4XHighPrecision {
      try visitor.visitSingularEnumField(value: self.precision, fieldNumber: 3)
    }
    if self.heater != .sht4XNoHeater {
      try visitor.visitSingularEnumField(value: self.heater, fieldNumber: 4)
    }
    if !self.payload.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.payload, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SHTPacket, rhs: SHTPacket) -> Bool {
    if lhs.packetIndex != rhs.packetIndex {return false}
    if lhs.samplePeriod != rhs.samplePeriod {return false}
    if lhs.precision != rhs.precision {return false}
    if lhs.heater != rhs.heater {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SHTPacket.Payload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = SHTPacket.protoMessageName + ".Payload"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "timestamp_unix"),
    2: .standard(proto: "timestamp_ms_from_start"),
    3: .same(proto: "temperature"),
    4: .same(proto: "humidity"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.timestampUnix) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.timestampMsFromStart) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.temperature) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.humidity) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.timestampUnix != 0 {
      try visitor.visitSingularUInt32Field(value: self.timestampUnix, fieldNumber: 1)
    }
    if self.timestampMsFromStart != 0 {
      try visitor.visitSingularUInt32Field(value: self.timestampMsFromStart, fieldNumber: 2)
    }
    if self.temperature != 0 {
      try visitor.visitSingularFloatField(value: self.temperature, fieldNumber: 3)
    }
    if self.humidity != 0 {
      try visitor.visitSingularFloatField(value: self.humidity, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SHTPacket.Payload, rhs: SHTPacket.Payload) -> Bool {
    if lhs.timestampUnix != rhs.timestampUnix {return false}
    if lhs.timestampMsFromStart != rhs.timestampMsFromStart {return false}
    if lhs.temperature != rhs.temperature {return false}
    if lhs.humidity != rhs.humidity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpecPacket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SpecPacket"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "packet_index"),
    2: .standard(proto: "sample_period"),
    3: .standard(proto: "integration_time"),
    4: .standard(proto: "integration_step"),
    5: .same(proto: "gain"),
    6: .same(proto: "payload"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.packetIndex) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.samplePeriod) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.integrationTime) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.integrationStep) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.gain) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.payload) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.packetIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.packetIndex, fieldNumber: 1)
    }
    if self.samplePeriod != 0 {
      try visitor.visitSingularUInt32Field(value: self.samplePeriod, fieldNumber: 2)
    }
    if self.integrationTime != 0 {
      try visitor.visitSingularUInt32Field(value: self.integrationTime, fieldNumber: 3)
    }
    if self.integrationStep != 0 {
      try visitor.visitSingularUInt32Field(value: self.integrationStep, fieldNumber: 4)
    }
    if self.gain != .gain05X {
      try visitor.visitSingularEnumField(value: self.gain, fieldNumber: 5)
    }
    if !self.payload.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.payload, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SpecPacket, rhs: SpecPacket) -> Bool {
    if lhs.packetIndex != rhs.packetIndex {return false}
    if lhs.samplePeriod != rhs.samplePeriod {return false}
    if lhs.integrationTime != rhs.integrationTime {return false}
    if lhs.integrationStep != rhs.integrationStep {return false}
    if lhs.gain != rhs.gain {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpecPacket.Payload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = SpecPacket.protoMessageName + ".Payload"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "band_415"),
    2: .standard(proto: "band_445"),
    3: .standard(proto: "band_480"),
    4: .standard(proto: "band_515"),
    5: .standard(proto: "band_clear_1"),
    6: .standard(proto: "band_nir_1"),
    7: .standard(proto: "band_555"),
    8: .standard(proto: "band_590"),
    9: .standard(proto: "band_630"),
    10: .standard(proto: "band_680"),
    11: .standard(proto: "band_clear_2"),
    12: .standard(proto: "band_nir_2"),
    13: .same(proto: "flicker"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.band415) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.band445) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.band480) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.band515) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.bandClear1) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.bandNir1) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.band555) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self.band590) }()
      case 9: try { try decoder.decodeSingularUInt32Field(value: &self.band630) }()
      case 10: try { try decoder.decodeSingularUInt32Field(value: &self.band680) }()
      case 11: try { try decoder.decodeSingularUInt32Field(value: &self.bandClear2) }()
      case 12: try { try decoder.decodeSingularUInt32Field(value: &self.bandNir2) }()
      case 13: try { try decoder.decodeSingularUInt32Field(value: &self.flicker) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.band415 != 0 {
      try visitor.visitSingularUInt32Field(value: self.band415, fieldNumber: 1)
    }
    if self.band445 != 0 {
      try visitor.visitSingularUInt32Field(value: self.band445, fieldNumber: 2)
    }
    if self.band480 != 0 {
      try visitor.visitSingularUInt32Field(value: self.band480, fieldNumber: 3)
    }
    if self.band515 != 0 {
      try visitor.visitSingularUInt32Field(value: self.band515, fieldNumber: 4)
    }
    if self.bandClear1 != 0 {
      try visitor.visitSingularUInt32Field(value: self.bandClear1, fieldNumber: 5)
    }
    if self.bandNir1 != 0 {
      try visitor.visitSingularUInt32Field(value: self.bandNir1, fieldNumber: 6)
    }
    if self.band555 != 0 {
      try visitor.visitSingularUInt32Field(value: self.band555, fieldNumber: 7)
    }
    if self.band590 != 0 {
      try visitor.visitSingularUInt32Field(value: self.band590, fieldNumber: 8)
    }
    if self.band630 != 0 {
      try visitor.visitSingularUInt32Field(value: self.band630, fieldNumber: 9)
    }
    if self.band680 != 0 {
      try visitor.visitSingularUInt32Field(value: self.band680, fieldNumber: 10)
    }
    if self.bandClear2 != 0 {
      try visitor.visitSingularUInt32Field(value: self.bandClear2, fieldNumber: 11)
    }
    if self.bandNir2 != 0 {
      try visitor.visitSingularUInt32Field(value: self.bandNir2, fieldNumber: 12)
    }
    if self.flicker != 0 {
      try visitor.visitSingularUInt32Field(value: self.flicker, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SpecPacket.Payload, rhs: SpecPacket.Payload) -> Bool {
    if lhs.band415 != rhs.band415 {return false}
    if lhs.band445 != rhs.band445 {return false}
    if lhs.band480 != rhs.band480 {return false}
    if lhs.band515 != rhs.band515 {return false}
    if lhs.bandClear1 != rhs.bandClear1 {return false}
    if lhs.bandNir1 != rhs.bandNir1 {return false}
    if lhs.band555 != rhs.band555 {return false}
    if lhs.band590 != rhs.band590 {return false}
    if lhs.band630 != rhs.band630 {return false}
    if lhs.band680 != rhs.band680 {return false}
    if lhs.bandClear2 != rhs.bandClear2 {return false}
    if lhs.bandNir2 != rhs.bandNir2 {return false}
    if lhs.flicker != rhs.flicker {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ThermPacket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ThermPacket"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "packet_index"),
    2: .standard(proto: "sample_period"),
    3: .same(proto: "payload"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.packetIndex) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.samplePeriod) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.payload) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.packetIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.packetIndex, fieldNumber: 1)
    }
    if self.samplePeriod != 0 {
      try visitor.visitSingularUInt32Field(value: self.samplePeriod, fieldNumber: 2)
    }
    if !self.payload.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.payload, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ThermPacket, rhs: ThermPacket) -> Bool {
    if lhs.packetIndex != rhs.packetIndex {return false}
    if lhs.samplePeriod != rhs.samplePeriod {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ThermPacket.Payload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ThermPacket.protoMessageName + ".Payload"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "descriptor"),
    2: .standard(proto: "timestamp_unix"),
    3: .standard(proto: "timestamp_ms_from_start"),
    4: .standard(proto: "ambient_raw"),
    5: .standard(proto: "object_raw"),
    6: .standard(proto: "ambient_temp"),
    7: .standard(proto: "object_temp"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.descriptor) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.timestampUnix) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.timestampMsFromStart) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.ambientRaw) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.objectRaw) }()
      case 6: try { try decoder.decodeSingularFloatField(value: &self.ambientTemp) }()
      case 7: try { try decoder.decodeSingularFloatField(value: &self.objectTemp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.descriptor != .tipOfNose {
      try visitor.visitSingularEnumField(value: self.descriptor, fieldNumber: 1)
    }
    if self.timestampUnix != 0 {
      try visitor.visitSingularUInt32Field(value: self.timestampUnix, fieldNumber: 2)
    }
    if self.timestampMsFromStart != 0 {
      try visitor.visitSingularUInt32Field(value: self.timestampMsFromStart, fieldNumber: 3)
    }
    if self.ambientRaw != 0 {
      try visitor.visitSingularUInt32Field(value: self.ambientRaw, fieldNumber: 4)
    }
    if self.objectRaw != 0 {
      try visitor.visitSingularUInt32Field(value: self.objectRaw, fieldNumber: 5)
    }
    if self.ambientTemp != 0 {
      try visitor.visitSingularFloatField(value: self.ambientTemp, fieldNumber: 6)
    }
    if self.objectTemp != 0 {
      try visitor.visitSingularFloatField(value: self.objectTemp, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ThermPacket.Payload, rhs: ThermPacket.Payload) -> Bool {
    if lhs.descriptor != rhs.descriptor {return false}
    if lhs.timestampUnix != rhs.timestampUnix {return false}
    if lhs.timestampMsFromStart != rhs.timestampMsFromStart {return false}
    if lhs.ambientRaw != rhs.ambientRaw {return false}
    if lhs.objectRaw != rhs.objectRaw {return false}
    if lhs.ambientTemp != rhs.ambientTemp {return false}
    if lhs.objectTemp != rhs.objectTemp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension IMU_Accel_Settings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "IMU_Accel_Settings"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cutoff"),
    2: .same(proto: "range"),
    3: .standard(proto: "sample_rate_divisor"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._cutoff) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.range) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.sampleRateDivisor) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._cutoff {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    if self.range != .range2G {
      try visitor.visitSingularEnumField(value: self.range, fieldNumber: 2)
    }
    if self.sampleRateDivisor != 0 {
      try visitor.visitSingularUInt32Field(value: self.sampleRateDivisor, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: IMU_Accel_Settings, rhs: IMU_Accel_Settings) -> Bool {
    if lhs._cutoff != rhs._cutoff {return false}
    if lhs.range != rhs.range {return false}
    if lhs.sampleRateDivisor != rhs.sampleRateDivisor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension IMU_Gyro_Settings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "IMU_Gyro_Settings"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cutoff"),
    2: .same(proto: "range"),
    3: .standard(proto: "sample_rate_divisor"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._cutoff) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.range) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.sampleRateDivisor) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._cutoff {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    if self.range != .range250Dps {
      try visitor.visitSingularEnumField(value: self.range, fieldNumber: 2)
    }
    if self.sampleRateDivisor != 0 {
      try visitor.visitSingularUInt32Field(value: self.sampleRateDivisor, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: IMU_Gyro_Settings, rhs: IMU_Gyro_Settings) -> Bool {
    if lhs._cutoff != rhs._cutoff {return false}
    if lhs.range != rhs.range {return false}
    if lhs.sampleRateDivisor != rhs.sampleRateDivisor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension IMUPacket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "IMUPacket"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "packet_index"),
    2: .standard(proto: "accel_settings"),
    3: .standard(proto: "gyro_settings"),
    4: .same(proto: "payload"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.packetIndex) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._accelSettings) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._gyroSettings) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._payload) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.packetIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.packetIndex, fieldNumber: 1)
    }
    try { if let v = self._accelSettings {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._gyroSettings {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._payload {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: IMUPacket, rhs: IMUPacket) -> Bool {
    if lhs.packetIndex != rhs.packetIndex {return false}
    if lhs._accelSettings != rhs._accelSettings {return false}
    if lhs._gyroSettings != rhs._gyroSettings {return false}
    if lhs._payload != rhs._payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension IMUPacket.Payload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = IMUPacket.protoMessageName + ".Payload"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sample"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.sample) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sample.isEmpty {
      try visitor.visitSingularBytesField(value: self.sample, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: IMUPacket.Payload, rhs: IMUPacket.Payload) -> Bool {
    if lhs.sample != rhs.sample {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MicPacket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "MicPacket"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "packet_index"),
    3: .standard(proto: "sample_period"),
    2: .standard(proto: "mic_sample_freq"),
    4: .standard(proto: "samples_per_fft"),
    5: .standard(proto: "start_frequency"),
    6: .standard(proto: "frequency_spacing"),
    7: .same(proto: "payload"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.packetIndex) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.micSampleFreq) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.samplePeriod) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.samplesPerFft) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self.startFrequency) }()
      case 6: try { try decoder.decodeSingularFloatField(value: &self.frequencySpacing) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._payload) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.packetIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.packetIndex, fieldNumber: 1)
    }
    if self.micSampleFreq != 0 {
      try visitor.visitSingularUInt32Field(value: self.micSampleFreq, fieldNumber: 2)
    }
    if self.samplePeriod != 0 {
      try visitor.visitSingularUInt32Field(value: self.samplePeriod, fieldNumber: 3)
    }
    if self.samplesPerFft != 0 {
      try visitor.visitSingularUInt32Field(value: self.samplesPerFft, fieldNumber: 4)
    }
    if self.startFrequency != 0 {
      try visitor.visitSingularFloatField(value: self.startFrequency, fieldNumber: 5)
    }
    if self.frequencySpacing != 0 {
      try visitor.visitSingularFloatField(value: self.frequencySpacing, fieldNumber: 6)
    }
    try { if let v = self._payload {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MicPacket, rhs: MicPacket) -> Bool {
    if lhs.packetIndex != rhs.packetIndex {return false}
    if lhs.samplePeriod != rhs.samplePeriod {return false}
    if lhs.micSampleFreq != rhs.micSampleFreq {return false}
    if lhs.samplesPerFft != rhs.samplesPerFft {return false}
    if lhs.startFrequency != rhs.startFrequency {return false}
    if lhs.frequencySpacing != rhs.frequencySpacing {return false}
    if lhs._payload != rhs._payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MicPacket.Payload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = MicPacket.protoMessageName + ".Payload"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sample"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedFloatField(value: &self.sample) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sample.isEmpty {
      try visitor.visitPackedFloatField(value: self.sample, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MicPacket.Payload, rhs: MicPacket.Payload) -> Bool {
    if lhs.sample != rhs.sample {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AirSpecColors: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "AirSpecColors"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "red"),
    2: .same(proto: "green"),
    3: .same(proto: "blue"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.red) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.green) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.blue) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.red != 0 {
      try visitor.visitSingularUInt32Field(value: self.red, fieldNumber: 1)
    }
    if self.green != 0 {
      try visitor.visitSingularUInt32Field(value: self.green, fieldNumber: 2)
    }
    if self.blue != 0 {
      try visitor.visitSingularUInt32Field(value: self.blue, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: AirSpecColors, rhs: AirSpecColors) -> Bool {
    if lhs.red != rhs.red {return false}
    if lhs.green != rhs.green {return false}
    if lhs.blue != rhs.blue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AirSpecColorPosition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "AirSpecColorPosition"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "forward"),
    2: .same(proto: "eye"),
    3: .same(proto: "top"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._forward) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._eye) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._top) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._forward {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._eye {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._top {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: AirSpecColorPosition, rhs: AirSpecColorPosition) -> Bool {
    if lhs._forward != rhs._forward {return false}
    if lhs._eye != rhs._eye {return false}
    if lhs._top != rhs._top {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LightControlPacket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "LightControlPacket"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "left"),
    2: .same(proto: "right"),
  ]

  fileprivate class _StorageClass {
    var _left: AirSpecColorPosition? = nil
    var _right: AirSpecColorPosition? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _left = source._left
      _right = source._right
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._left) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._right) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._left {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._right {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: LightControlPacket, rhs: LightControlPacket) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._left != rhs_storage._left {return false}
        if _storage._right != rhs_storage._right {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SensorControl: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SensorControl"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "enable_all"),
    2: .same(proto: "spectrometer"),
    3: .same(proto: "bme688"),
    4: .same(proto: "imu"),
    5: .same(proto: "thermopiles"),
    6: .same(proto: "lux"),
    7: .same(proto: "mic"),
    8: .same(proto: "sht"),
    9: .same(proto: "sgp"),
    10: .same(proto: "blink"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enableAll) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.spectrometer) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.bme688) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.imu) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.thermopiles) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.lux) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.mic) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.sht) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.sgp) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self.blink) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enableAll != false {
      try visitor.visitSingularBoolField(value: self.enableAll, fieldNumber: 1)
    }
    if self.spectrometer != false {
      try visitor.visitSingularBoolField(value: self.spectrometer, fieldNumber: 2)
    }
    if self.bme688 != false {
      try visitor.visitSingularBoolField(value: self.bme688, fieldNumber: 3)
    }
    if self.imu != false {
      try visitor.visitSingularBoolField(value: self.imu, fieldNumber: 4)
    }
    if self.thermopiles != false {
      try visitor.visitSingularBoolField(value: self.thermopiles, fieldNumber: 5)
    }
    if self.lux != false {
      try visitor.visitSingularBoolField(value: self.lux, fieldNumber: 6)
    }
    if self.mic != false {
      try visitor.visitSingularBoolField(value: self.mic, fieldNumber: 7)
    }
    if self.sht != false {
      try visitor.visitSingularBoolField(value: self.sht, fieldNumber: 8)
    }
    if self.sgp != false {
      try visitor.visitSingularBoolField(value: self.sgp, fieldNumber: 9)
    }
    if self.blink != false {
      try visitor.visitSingularBoolField(value: self.blink, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SensorControl, rhs: SensorControl) -> Bool {
    if lhs.enableAll != rhs.enableAll {return false}
    if lhs.spectrometer != rhs.spectrometer {return false}
    if lhs.bme688 != rhs.bme688 {return false}
    if lhs.imu != rhs.imu {return false}
    if lhs.thermopiles != rhs.thermopiles {return false}
    if lhs.lux != rhs.lux {return false}
    if lhs.mic != rhs.mic {return false}
    if lhs.sht != rhs.sht {return false}
    if lhs.sgp != rhs.sgp {return false}
    if lhs.blink != rhs.blink {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LuxSensorConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "LuxSensorConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sample_period_ms"),
    2: .same(proto: "gain"),
    3: .standard(proto: "integration_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.samplePeriodMs) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.gain) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.integrationTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.samplePeriodMs != 0 {
      try visitor.visitSingularUInt32Field(value: self.samplePeriodMs, fieldNumber: 1)
    }
    if self.gain != .tsl2722Gain1X {
      try visitor.visitSingularEnumField(value: self.gain, fieldNumber: 2)
    }
    if self.integrationTime != .tsl2722Integrationtime600Ms {
      try visitor.visitSingularEnumField(value: self.integrationTime, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: LuxSensorConfig, rhs: LuxSensorConfig) -> Bool {
    if lhs.samplePeriodMs != rhs.samplePeriodMs {return false}
    if lhs.gain != rhs.gain {return false}
    if lhs.integrationTime != rhs.integrationTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SGP_Sensor_Config: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SGP_Sensor_Config"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sample_period_ms"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.samplePeriodMs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.samplePeriodMs != 0 {
      try visitor.visitSingularUInt32Field(value: self.samplePeriodMs, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SGP_Sensor_Config, rhs: SGP_Sensor_Config) -> Bool {
    if lhs.samplePeriodMs != rhs.samplePeriodMs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BME_Sensor_Config: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "BME_Sensor_Config"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sample_period_ms"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.samplePeriodMs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.samplePeriodMs != 0 {
      try visitor.visitSingularUInt32Field(value: self.samplePeriodMs, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BME_Sensor_Config, rhs: BME_Sensor_Config) -> Bool {
    if lhs.samplePeriodMs != rhs.samplePeriodMs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ColorSensorConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ColorSensorConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sample_period_ms"),
    2: .standard(proto: "integration_time"),
    3: .standard(proto: "integration_step"),
    4: .same(proto: "gain"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.samplePeriodMs) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.integrationTime) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.integrationStep) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.gain) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.samplePeriodMs != 0 {
      try visitor.visitSingularUInt32Field(value: self.samplePeriodMs, fieldNumber: 1)
    }
    if self.integrationTime != 0 {
      try visitor.visitSingularUInt32Field(value: self.integrationTime, fieldNumber: 2)
    }
    if self.integrationStep != 0 {
      try visitor.visitSingularUInt32Field(value: self.integrationStep, fieldNumber: 3)
    }
    if self.gain != .gain05X {
      try visitor.visitSingularEnumField(value: self.gain, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ColorSensorConfig, rhs: ColorSensorConfig) -> Bool {
    if lhs.samplePeriodMs != rhs.samplePeriodMs {return false}
    if lhs.integrationTime != rhs.integrationTime {return false}
    if lhs.integrationStep != rhs.integrationStep {return false}
    if lhs.gain != rhs.gain {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ThermopileSensorConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ThermopileSensorConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sample_period_ms"),
    2: .standard(proto: "enable_top_of_nose"),
    3: .standard(proto: "enable_nose_bridge"),
    4: .standard(proto: "enable_front_temple"),
    5: .standard(proto: "enable_mid_temple"),
    6: .standard(proto: "enable_rear_temple"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.samplePeriodMs) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.enableTopOfNose) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.enableNoseBridge) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.enableFrontTemple) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.enableMidTemple) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.enableRearTemple) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.samplePeriodMs != 0 {
      try visitor.visitSingularUInt32Field(value: self.samplePeriodMs, fieldNumber: 1)
    }
    if self.enableTopOfNose != false {
      try visitor.visitSingularBoolField(value: self.enableTopOfNose, fieldNumber: 2)
    }
    if self.enableNoseBridge != false {
      try visitor.visitSingularBoolField(value: self.enableNoseBridge, fieldNumber: 3)
    }
    if self.enableFrontTemple != false {
      try visitor.visitSingularBoolField(value: self.enableFrontTemple, fieldNumber: 4)
    }
    if self.enableMidTemple != false {
      try visitor.visitSingularBoolField(value: self.enableMidTemple, fieldNumber: 5)
    }
    if self.enableRearTemple != false {
      try visitor.visitSingularBoolField(value: self.enableRearTemple, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ThermopileSensorConfig, rhs: ThermopileSensorConfig) -> Bool {
    if lhs.samplePeriodMs != rhs.samplePeriodMs {return false}
    if lhs.enableTopOfNose != rhs.enableTopOfNose {return false}
    if lhs.enableNoseBridge != rhs.enableNoseBridge {return false}
    if lhs.enableFrontTemple != rhs.enableFrontTemple {return false}
    if lhs.enableMidTemple != rhs.enableMidTemple {return false}
    if lhs.enableRearTemple != rhs.enableRearTemple {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BlinkSensorConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "BlinkSensorConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sample_frequency"),
    2: .standard(proto: "enable_daylight_compensation"),
    3: .same(proto: "daylightCompensationUpperThresh"),
    4: .same(proto: "daylightCompensationLowerThresh"),
    5: .standard(proto: "enable_windowing"),
    6: .standard(proto: "window_size_ms"),
    7: .standard(proto: "window_period_ms"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.sampleFrequency) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.enableDaylightCompensation) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.daylightCompensationUpperThresh) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.daylightCompensationLowerThresh) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.enableWindowing) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.windowSizeMs) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.windowPeriodMs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sampleFrequency != 0 {
      try visitor.visitSingularUInt32Field(value: self.sampleFrequency, fieldNumber: 1)
    }
    if self.enableDaylightCompensation != false {
      try visitor.visitSingularBoolField(value: self.enableDaylightCompensation, fieldNumber: 2)
    }
    if self.daylightCompensationUpperThresh != 0 {
      try visitor.visitSingularUInt32Field(value: self.daylightCompensationUpperThresh, fieldNumber: 3)
    }
    if self.daylightCompensationLowerThresh != 0 {
      try visitor.visitSingularUInt32Field(value: self.daylightCompensationLowerThresh, fieldNumber: 4)
    }
    if self.enableWindowing != 0 {
      try visitor.visitSingularUInt32Field(value: self.enableWindowing, fieldNumber: 5)
    }
    if self.windowSizeMs != 0 {
      try visitor.visitSingularUInt32Field(value: self.windowSizeMs, fieldNumber: 6)
    }
    if self.windowPeriodMs != 0 {
      try visitor.visitSingularUInt32Field(value: self.windowPeriodMs, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BlinkSensorConfig, rhs: BlinkSensorConfig) -> Bool {
    if lhs.sampleFrequency != rhs.sampleFrequency {return false}
    if lhs.enableDaylightCompensation != rhs.enableDaylightCompensation {return false}
    if lhs.daylightCompensationUpperThresh != rhs.daylightCompensationUpperThresh {return false}
    if lhs.daylightCompensationLowerThresh != rhs.daylightCompensationLowerThresh {return false}
    if lhs.enableWindowing != rhs.enableWindowing {return false}
    if lhs.windowSizeMs != rhs.windowSizeMs {return false}
    if lhs.windowPeriodMs != rhs.windowPeriodMs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MicSensorConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "MicSensorConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sample_period_ms"),
    2: .standard(proto: "mic_sample_freq"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.samplePeriodMs) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.micSampleFreq) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.samplePeriodMs != 0 {
      try visitor.visitSingularUInt32Field(value: self.samplePeriodMs, fieldNumber: 1)
    }
    if self.micSampleFreq != 0 {
      try visitor.visitSingularUInt32Field(value: self.micSampleFreq, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MicSensorConfig, rhs: MicSensorConfig) -> Bool {
    if lhs.samplePeriodMs != rhs.samplePeriodMs {return false}
    if lhs.micSampleFreq != rhs.micSampleFreq {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension HumiditySensorConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "HumiditySensorConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sample_period_ms"),
    2: .same(proto: "precisionLevel"),
    3: .same(proto: "heaterSettings"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.samplePeriodMs) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.precisionLevel) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.heaterSettings) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.samplePeriodMs != 0 {
      try visitor.visitSingularUInt32Field(value: self.samplePeriodMs, fieldNumber: 1)
    }
    if self.precisionLevel != .sht4XHighPrecision {
      try visitor.visitSingularEnumField(value: self.precisionLevel, fieldNumber: 2)
    }
    if self.heaterSettings != .sht4XNoHeater {
      try visitor.visitSingularEnumField(value: self.heaterSettings, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: HumiditySensorConfig, rhs: HumiditySensorConfig) -> Bool {
    if lhs.samplePeriodMs != rhs.samplePeriodMs {return false}
    if lhs.precisionLevel != rhs.precisionLevel {return false}
    if lhs.heaterSettings != rhs.heaterSettings {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension IMU_SensorConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "IMU_SensorConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "accel_settings"),
    2: .standard(proto: "gyro_settings"),
    3: .standard(proto: "enable_windowing"),
    4: .standard(proto: "window_size_ms"),
    5: .standard(proto: "window_period_ms"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._accelSettings) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._gyroSettings) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.enableWindowing) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.windowSizeMs) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.windowPeriodMs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._accelSettings {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._gyroSettings {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.enableWindowing != 0 {
      try visitor.visitSingularUInt32Field(value: self.enableWindowing, fieldNumber: 3)
    }
    if self.windowSizeMs != 0 {
      try visitor.visitSingularUInt32Field(value: self.windowSizeMs, fieldNumber: 4)
    }
    if self.windowPeriodMs != 0 {
      try visitor.visitSingularUInt32Field(value: self.windowPeriodMs, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: IMU_SensorConfig, rhs: IMU_SensorConfig) -> Bool {
    if lhs._accelSettings != rhs._accelSettings {return false}
    if lhs._gyroSettings != rhs._gyroSettings {return false}
    if lhs.enableWindowing != rhs.enableWindowing {return false}
    if lhs.windowSizeMs != rhs.windowSizeMs {return false}
    if lhs.windowPeriodMs != rhs.windowPeriodMs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SensorConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SensorConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "lux"),
    2: .same(proto: "sgp"),
    3: .same(proto: "bme"),
    4: .same(proto: "color"),
    5: .same(proto: "thermopile"),
    6: .same(proto: "blink"),
    7: .same(proto: "mic"),
    8: .same(proto: "humidity"),
    9: .same(proto: "imu"),
  ]

  fileprivate class _StorageClass {
    var _lux: LuxSensorConfig? = nil
    var _sgp: SGP_Sensor_Config? = nil
    var _bme: BME_Sensor_Config? = nil
    var _color: ColorSensorConfig? = nil
    var _thermopile: ThermopileSensorConfig? = nil
    var _blink: BlinkSensorConfig? = nil
    var _mic: MicSensorConfig? = nil
    var _humidity: HumiditySensorConfig? = nil
    var _imu: IMU_SensorConfig? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _lux = source._lux
      _sgp = source._sgp
      _bme = source._bme
      _color = source._color
      _thermopile = source._thermopile
      _blink = source._blink
      _mic = source._mic
      _humidity = source._humidity
      _imu = source._imu
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._lux) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._sgp) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._bme) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._color) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._thermopile) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._blink) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._mic) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._humidity) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._imu) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._lux {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._sgp {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._bme {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._color {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._thermopile {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._blink {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._mic {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._humidity {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._imu {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SensorConfig, rhs: SensorConfig) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._lux != rhs_storage._lux {return false}
        if _storage._sgp != rhs_storage._sgp {return false}
        if _storage._bme != rhs_storage._bme {return false}
        if _storage._color != rhs_storage._color {return false}
        if _storage._thermopile != rhs_storage._thermopile {return false}
        if _storage._blink != rhs_storage._blink {return false}
        if _storage._mic != rhs_storage._mic {return false}
        if _storage._humidity != rhs_storage._humidity {return false}
        if _storage._imu != rhs_storage._imu {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DFU_Mode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "DFU_Mode"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enable"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enable) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enable != false {
      try visitor.visitSingularBoolField(value: self.enable, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: DFU_Mode, rhs: DFU_Mode) -> Bool {
    if lhs.enable != rhs.enable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BlueGreenTransition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "BlueGreenTransition"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enable"),
    2: .standard(proto: "blue_min_intensity"),
    3: .standard(proto: "blue_max_intensity"),
    4: .standard(proto: "green_max_intensity"),
    5: .standard(proto: "step_size"),
    6: .standard(proto: "step_duration_ms"),
    7: .standard(proto: "green_hold_length_seconds"),
    8: .standard(proto: "transition_delay_seconds"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enable) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.blueMinIntensity) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.blueMaxIntensity) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.greenMaxIntensity) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.stepSize) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.stepDurationMs) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.greenHoldLengthSeconds) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self.transitionDelaySeconds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enable != false {
      try visitor.visitSingularBoolField(value: self.enable, fieldNumber: 1)
    }
    if self.blueMinIntensity != 0 {
      try visitor.visitSingularUInt32Field(value: self.blueMinIntensity, fieldNumber: 2)
    }
    if self.blueMaxIntensity != 0 {
      try visitor.visitSingularUInt32Field(value: self.blueMaxIntensity, fieldNumber: 3)
    }
    if self.greenMaxIntensity != 0 {
      try visitor.visitSingularUInt32Field(value: self.greenMaxIntensity, fieldNumber: 4)
    }
    if self.stepSize != 0 {
      try visitor.visitSingularUInt32Field(value: self.stepSize, fieldNumber: 5)
    }
    if self.stepDurationMs != 0 {
      try visitor.visitSingularUInt32Field(value: self.stepDurationMs, fieldNumber: 6)
    }
    if self.greenHoldLengthSeconds != 0 {
      try visitor.visitSingularUInt32Field(value: self.greenHoldLengthSeconds, fieldNumber: 7)
    }
    if self.transitionDelaySeconds != 0 {
      try visitor.visitSingularUInt32Field(value: self.transitionDelaySeconds, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BlueGreenTransition, rhs: BlueGreenTransition) -> Bool {
    if lhs.enable != rhs.enable {return false}
    if lhs.blueMinIntensity != rhs.blueMinIntensity {return false}
    if lhs.blueMaxIntensity != rhs.blueMaxIntensity {return false}
    if lhs.greenMaxIntensity != rhs.greenMaxIntensity {return false}
    if lhs.stepSize != rhs.stepSize {return false}
    if lhs.stepDurationMs != rhs.stepDurationMs {return false}
    if lhs.greenHoldLengthSeconds != rhs.greenHoldLengthSeconds {return false}
    if lhs.transitionDelaySeconds != rhs.transitionDelaySeconds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RedFlashTask: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "RedFlashTask"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enable"),
    2: .standard(proto: "red_max_intensity"),
    3: .standard(proto: "red_min_intensity"),
    4: .same(proto: "frequency"),
    5: .standard(proto: "duration_ms"),
    6: .standard(proto: "enable_speaker"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enable) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.redMaxIntensity) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.redMinIntensity) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.frequency) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.durationMs) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.enableSpeaker) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enable != false {
      try visitor.visitSingularBoolField(value: self.enable, fieldNumber: 1)
    }
    if self.redMaxIntensity != 0 {
      try visitor.visitSingularUInt32Field(value: self.redMaxIntensity, fieldNumber: 2)
    }
    if self.redMinIntensity != 0 {
      try visitor.visitSingularUInt32Field(value: self.redMinIntensity, fieldNumber: 3)
    }
    if self.frequency != 0 {
      try visitor.visitSingularUInt32Field(value: self.frequency, fieldNumber: 4)
    }
    if self.durationMs != 0 {
      try visitor.visitSingularUInt32Field(value: self.durationMs, fieldNumber: 5)
    }
    if self.enableSpeaker != 0 {
      try visitor.visitSingularUInt32Field(value: self.enableSpeaker, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RedFlashTask, rhs: RedFlashTask) -> Bool {
    if lhs.enable != rhs.enable {return false}
    if lhs.redMaxIntensity != rhs.redMaxIntensity {return false}
    if lhs.redMinIntensity != rhs.redMinIntensity {return false}
    if lhs.frequency != rhs.frequency {return false}
    if lhs.durationMs != rhs.durationMs {return false}
    if lhs.enableSpeaker != rhs.enableSpeaker {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AirSpecConfigHeader: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "AirSpecConfigHeader"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "timestamp_unix"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.timestampUnix) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.timestampUnix != 0 {
      try visitor.visitSingularUInt32Field(value: self.timestampUnix, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: AirSpecConfigHeader, rhs: AirSpecConfigHeader) -> Bool {
    if lhs.timestampUnix != rhs.timestampUnix {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AirSpecConfigPacket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "AirSpecConfigPacket"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .standard(proto: "ctrl_indiv_led"),
    3: .standard(proto: "sensor_control"),
    4: .standard(proto: "sensor_config"),
    5: .standard(proto: "dfu_mode"),
    6: .same(proto: "blueGreenTransition"),
    7: .same(proto: "redFlashTask"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      case 2: try {
        var v: LightControlPacket?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .ctrlIndivLed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .ctrlIndivLed(v)
        }
      }()
      case 3: try {
        var v: SensorControl?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .sensorControl(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .sensorControl(v)
        }
      }()
      case 4: try {
        var v: SensorConfig?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .sensorConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .sensorConfig(v)
        }
      }()
      case 5: try {
        var v: DFU_Mode?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .dfuMode(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .dfuMode(v)
        }
      }()
      case 6: try {
        var v: BlueGreenTransition?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .blueGreenTransition(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .blueGreenTransition(v)
        }
      }()
      case 7: try {
        var v: RedFlashTask?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .redFlashTask(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .redFlashTask(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    switch self.payload {
    case .ctrlIndivLed?: try {
      guard case .ctrlIndivLed(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .sensorControl?: try {
      guard case .sensorControl(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .sensorConfig?: try {
      guard case .sensorConfig(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .dfuMode?: try {
      guard case .dfuMode(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .blueGreenTransition?: try {
      guard case .blueGreenTransition(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .redFlashTask?: try {
      guard case .redFlashTask(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: AirSpecConfigPacket, rhs: AirSpecConfigPacket) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension systemState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "systemState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "firmware_version"),
    2: .same(proto: "control"),
    3: .same(proto: "config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.firmwareVersion) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._control) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._config) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.firmwareVersion != 0 {
      try visitor.visitSingularUInt32Field(value: self.firmwareVersion, fieldNumber: 1)
    }
    try { if let v = self._control {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._config {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: systemState, rhs: systemState) -> Bool {
    if lhs.firmwareVersion != rhs.firmwareVersion {return false}
    if lhs._control != rhs._control {return false}
    if lhs._config != rhs._config {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension appSurveyDataPayload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "appSurveyDataPayload"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "q_index"),
    2: .standard(proto: "q_choice"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.qIndex) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.qChoice) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.qIndex != 0 {
      try visitor.visitSingularInt32Field(value: self.qIndex, fieldNumber: 1)
    }
    if !self.qChoice.isEmpty {
      try visitor.visitSingularStringField(value: self.qChoice, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: appSurveyDataPayload, rhs: appSurveyDataPayload) -> Bool {
    if lhs.qIndex != rhs.qIndex {return false}
    if lhs.qChoice != rhs.qChoice {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension appSurveyDataPacket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "appSurveyDataPacket"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "UID_phone"),
    2: .same(proto: "payload"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.uidPhone) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.payload) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.uidPhone != 0 {
      try visitor.visitSingularUInt32Field(value: self.uidPhone, fieldNumber: 1)
    }
    if !self.payload.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.payload, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: appSurveyDataPacket, rhs: appSurveyDataPacket) -> Bool {
    if lhs.uidPhone != rhs.uidPhone {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension appMetaDataPacket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "appMetaDataPacket"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "UID_phone"),
    2: .same(proto: "payload"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.uidPhone) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.payload) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.uidPhone != 0 {
      try visitor.visitSingularUInt32Field(value: self.uidPhone, fieldNumber: 1)
    }
    if !self.payload.isEmpty {
      try visitor.visitSingularStringField(value: self.payload, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: appMetaDataPacket, rhs: appMetaDataPacket) -> Bool {
    if lhs.uidPhone != rhs.uidPhone {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SensorPacket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SensorPacket"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .standard(proto: "lux_packet"),
    3: .standard(proto: "sgp_packet"),
    4: .standard(proto: "bme_packet"),
    5: .standard(proto: "blink_packet"),
    6: .standard(proto: "sht_packet"),
    7: .standard(proto: "spec_packet"),
    8: .standard(proto: "therm_packet"),
    9: .standard(proto: "imu_packet"),
    10: .standard(proto: "mic_packet"),
    11: .standard(proto: "survey_packet"),
    12: .standard(proto: "meta_data_packet"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      case 2: try {
        var v: LuxPacket?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .luxPacket(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .luxPacket(v)
        }
      }()
      case 3: try {
        var v: SGPPacket?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .sgpPacket(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .sgpPacket(v)
        }
      }()
      case 4: try {
        var v: BMEPacket?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .bmePacket(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .bmePacket(v)
        }
      }()
      case 5: try {
        var v: BlinkPacket?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .blinkPacket(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .blinkPacket(v)
        }
      }()
      case 6: try {
        var v: SHTPacket?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .shtPacket(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .shtPacket(v)
        }
      }()
      case 7: try {
        var v: SpecPacket?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .specPacket(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .specPacket(v)
        }
      }()
      case 8: try {
        var v: ThermPacket?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .thermPacket(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .thermPacket(v)
        }
      }()
      case 9: try {
        var v: IMUPacket?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .imuPacket(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .imuPacket(v)
        }
      }()
      case 10: try {
        var v: MicPacket?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .micPacket(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .micPacket(v)
        }
      }()
      case 11: try {
        var v: appSurveyDataPacket?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .surveyPacket(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .surveyPacket(v)
        }
      }()
      case 12: try {
        var v: appMetaDataPacket?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .metaDataPacket(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .metaDataPacket(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    switch self.payload {
    case .luxPacket?: try {
      guard case .luxPacket(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .sgpPacket?: try {
      guard case .sgpPacket(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .bmePacket?: try {
      guard case .bmePacket(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .blinkPacket?: try {
      guard case .blinkPacket(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .shtPacket?: try {
      guard case .shtPacket(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .specPacket?: try {
      guard case .specPacket(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .thermPacket?: try {
      guard case .thermPacket(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .imuPacket?: try {
      guard case .imuPacket(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .micPacket?: try {
      guard case .micPacket(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .surveyPacket?: try {
      guard case .surveyPacket(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .metaDataPacket?: try {
      guard case .metaDataPacket(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SensorPacket, rhs: SensorPacket) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

