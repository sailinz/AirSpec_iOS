// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: message.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum SensorPacketTypes: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknownPacketType // = 0
  case ppgRed // = 1
  case ppgIr // = 2
  case spectrometer // = 3
  case bme // = 4
  case co2 // = 5
  case imu // = 6
  case thermopile // = 7
  case lux // = 8
  case lidar // = 9
  case mic // = 10
  case sht // = 11
  case sgp // = 12
  case blink // = 13
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknownPacketType
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownPacketType
    case 1: self = .ppgRed
    case 2: self = .ppgIr
    case 3: self = .spectrometer
    case 4: self = .bme
    case 5: self = .co2
    case 6: self = .imu
    case 7: self = .thermopile
    case 8: self = .lux
    case 9: self = .lidar
    case 10: self = .mic
    case 11: self = .sht
    case 12: self = .sgp
    case 13: self = .blink
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknownPacketType: return 0
    case .ppgRed: return 1
    case .ppgIr: return 2
    case .spectrometer: return 3
    case .bme: return 4
    case .co2: return 5
    case .imu: return 6
    case .thermopile: return 7
    case .lux: return 8
    case .lidar: return 9
    case .mic: return 10
    case .sht: return 11
    case .sgp: return 12
    case .blink: return 13
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension SensorPacketTypes: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [SensorPacketTypes] = [
    .unknownPacketType,
    .ppgRed,
    .ppgIr,
    .spectrometer,
    .bme,
    .co2,
    .imu,
    .thermopile,
    .lux,
    .lidar,
    .mic,
    .sht,
    .sgp,
    .blink,
  ]
}

#endif  // swift(>=4.2)

public enum Tsl2591Gain: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  //// low gain (1x)
  case tsl2722Gain1X // = 0

  //// medium gain (25x)
  case tsl2722Gain8X // = 1

  //// medium gain (428x)
  case tsl2722Gain16X // = 2

  //// max gain (9876x)
  case tsl2722Gain120X // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .tsl2722Gain1X
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .tsl2722Gain1X
    case 1: self = .tsl2722Gain8X
    case 2: self = .tsl2722Gain16X
    case 3: self = .tsl2722Gain120X
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .tsl2722Gain1X: return 0
    case .tsl2722Gain8X: return 1
    case .tsl2722Gain16X: return 2
    case .tsl2722Gain120X: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Tsl2591Gain: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Tsl2591Gain] = [
    .tsl2722Gain1X,
    .tsl2722Gain8X,
    .tsl2722Gain16X,
    .tsl2722Gain120X,
  ]
}

#endif  // swift(>=4.2)

public enum Tsl2591IntegrationTime: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// 699 millis
  case tsl2722Integrationtime600Ms // = 0

  /// 2.73 millis
  case tsl2722Integrationtime273Ms // = 255

  /// 27.3 millis
  case tsl2722Integrationtime2730Ms // = 246

  /// 101 millis
  case tsl2722Integrationtime101Ms // = 219

  /// 175 millis
  case tsl2722Integrationtime175Ms // = 192
  case UNRECOGNIZED(Int)

  public init() {
    self = .tsl2722Integrationtime600Ms
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .tsl2722Integrationtime600Ms
    case 192: self = .tsl2722Integrationtime175Ms
    case 219: self = .tsl2722Integrationtime101Ms
    case 246: self = .tsl2722Integrationtime2730Ms
    case 255: self = .tsl2722Integrationtime273Ms
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .tsl2722Integrationtime600Ms: return 0
    case .tsl2722Integrationtime175Ms: return 192
    case .tsl2722Integrationtime101Ms: return 219
    case .tsl2722Integrationtime2730Ms: return 246
    case .tsl2722Integrationtime273Ms: return 255
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Tsl2591IntegrationTime: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Tsl2591IntegrationTime] = [
    .tsl2722Integrationtime600Ms,
    .tsl2722Integrationtime273Ms,
    .tsl2722Integrationtime2730Ms,
    .tsl2722Integrationtime101Ms,
    .tsl2722Integrationtime175Ms,
  ]
}

#endif  // swift(>=4.2)

public enum Sht45_precision: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case sht4XHighPrecision // = 0
  case sht4XMedPrecision // = 1
  case sht4XLowPrecision // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .sht4XHighPrecision
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .sht4XHighPrecision
    case 1: self = .sht4XMedPrecision
    case 2: self = .sht4XLowPrecision
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .sht4XHighPrecision: return 0
    case .sht4XMedPrecision: return 1
    case .sht4XLowPrecision: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Sht45_precision: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Sht45_precision] = [
    .sht4XHighPrecision,
    .sht4XMedPrecision,
    .sht4XLowPrecision,
  ]
}

#endif  // swift(>=4.2)

///* Optional pre-heater configuration setting 
public enum Sht45_heater: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case sht4XNoHeater // = 0
  case sht4XHighHeater1S // = 1
  case sht4XHighHeater100Ms // = 2
  case sht4XMedHeater1S // = 3
  case sht4XMedHeater100Ms // = 4
  case sht4XLowHeater1S // = 5
  case sht4XLowHeater100Ms // = 6
  case UNRECOGNIZED(Int)

  public init() {
    self = .sht4XNoHeater
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .sht4XNoHeater
    case 1: self = .sht4XHighHeater1S
    case 2: self = .sht4XHighHeater100Ms
    case 3: self = .sht4XMedHeater1S
    case 4: self = .sht4XMedHeater100Ms
    case 5: self = .sht4XLowHeater1S
    case 6: self = .sht4XLowHeater100Ms
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .sht4XNoHeater: return 0
    case .sht4XHighHeater1S: return 1
    case .sht4XHighHeater100Ms: return 2
    case .sht4XMedHeater1S: return 3
    case .sht4XMedHeater100Ms: return 4
    case .sht4XLowHeater1S: return 5
    case .sht4XLowHeater100Ms: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Sht45_heater: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Sht45_heater] = [
    .sht4XNoHeater,
    .sht4XHighHeater1S,
    .sht4XHighHeater100Ms,
    .sht4XMedHeater1S,
    .sht4XMedHeater100Ms,
    .sht4XLowHeater1S,
    .sht4XLowHeater100Ms,
  ]
}

#endif  // swift(>=4.2)

public struct SensorPacketHeader {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var packetType: SensorPacketTypes = .unknownPacketType

  public var systemUid: UInt32 = 0

  public var packetID: UInt32 = 0

  public var msFromStart: UInt32 = 0

  public var epoch: UInt32 = 0

  public var payloadLength: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct LuxPacket {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var gain: Tsl2591Gain = .tsl2722Gain1X

  public var integrationTime: Tsl2591IntegrationTime = .tsl2722Integrationtime600Ms

  public var payload: [LuxPacket.Payload] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Payload {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var lux: UInt32 = 0

    public var timestamp: UInt32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct SGPPacket {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: [SGPPacket.Payload] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Payload {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var srawVoc: UInt32 = 0

    public var srawNox: UInt32 = 0

    public var vocIndexValue: Int32 = 0

    public var noxIndexValue: Int32 = 0

    public var timestamp: UInt32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct BMEPacket {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var samplePeriodMs: UInt32 = 0

  public var payload: [BMEPacket.Payload] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Payload {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var timeStamp: UInt64 = 0

    public var signal: Float = 0

    public var signalDimensions: UInt32 = 0

    public var sensorID: UInt32 = 0

    public var accuracy: UInt32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct BlinkPacket {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var diodeSaturationFlag: UInt32 = 0

  public var blinkSampleRate: UInt32 = 0

  public var subpacketIndex: UInt32 = 0

  public var payload: BlinkPacket.Payload {
    get {return _payload ?? BlinkPacket.Payload()}
    set {_payload = newValue}
  }
  /// Returns true if `payload` has been explicitly set.
  public var hasPayload: Bool {return self._payload != nil}
  /// Clears the value of `payload`. Subsequent reads from it will return its default value.
  public mutating func clearPayload() {self._payload = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Payload {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var sample: Data = Data()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _payload: BlinkPacket.Payload? = nil
}

public struct SHTPacket {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var precision: Sht45_precision = .sht4XHighPrecision

  public var heater: Sht45_heater = .sht4XNoHeater

  public var payload: [SHTPacket.Payload] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Payload {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var temperature: Float = 0

    public var humidity: Float = 0

    public var timestamp: UInt32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct SpecPacket {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var samplePeriod: UInt32 = 0

  public var payload: [SpecPacket.Payload] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Payload {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var _415: UInt32 = 0

    public var _445: UInt32 = 0

    public var _480: UInt32 = 0

    public var _515: UInt32 = 0

    public var clear1: UInt32 = 0

    public var nir1: UInt32 = 0

    public var _555: UInt32 = 0

    public var _590: UInt32 = 0

    public var _630: UInt32 = 0

    public var _680: UInt32 = 0

    public var clear2: UInt32 = 0

    public var nir2: UInt32 = 0

    public var flicker: UInt32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct ThermPacket {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var samplePeriodMs: UInt32 = 0

  public var payload: [ThermPacket.Payload] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Payload {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var descriptor: UInt32 = 0

    public var timestamp: UInt32 = 0

    public var ambientRaw: UInt32 = 0

    public var objectRaw: UInt32 = 0

    public var ambientTemp: Float = 0

    public var objectTemp: Float = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct IMUPacket {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var samplePeriodMs: UInt32 = 0

  public var payload: IMUPacket.Payload {
    get {return _payload ?? IMUPacket.Payload()}
    set {_payload = newValue}
  }
  /// Returns true if `payload` has been explicitly set.
  public var hasPayload: Bool {return self._payload != nil}
  /// Clears the value of `payload`. Subsequent reads from it will return its default value.
  public mutating func clearPayload() {self._payload = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Payload {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var sample: Data = Data()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _payload: IMUPacket.Payload? = nil
}

public struct MicPacket {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sampleFreq: UInt32 = 0

  public var systemSamplePeriod: UInt32 = 0

  public var samplesPerFft: UInt32 = 0

  public var startFrequency: Float = 0

  public var frequencySpacing: Float = 0

  public var payload: MicPacket.Payload {
    get {return _payload ?? MicPacket.Payload()}
    set {_payload = newValue}
  }
  /// Returns true if `payload` has been explicitly set.
  public var hasPayload: Bool {return self._payload != nil}
  /// Clears the value of `payload`. Subsequent reads from it will return its default value.
  public mutating func clearPayload() {self._payload = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Payload {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var sample: [Float] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _payload: MicPacket.Payload? = nil
}

public struct SensorPacket {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var header: SensorPacketHeader {
    get {return _storage._header ?? SensorPacketHeader()}
    set {_uniqueStorage()._header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return _storage._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {_uniqueStorage()._header = nil}

  public var luxPacket: LuxPacket {
    get {return _storage._luxPacket ?? LuxPacket()}
    set {_uniqueStorage()._luxPacket = newValue}
  }
  /// Returns true if `luxPacket` has been explicitly set.
  public var hasLuxPacket: Bool {return _storage._luxPacket != nil}
  /// Clears the value of `luxPacket`. Subsequent reads from it will return its default value.
  public mutating func clearLuxPacket() {_uniqueStorage()._luxPacket = nil}

  public var sgpPacket: SGPPacket {
    get {return _storage._sgpPacket ?? SGPPacket()}
    set {_uniqueStorage()._sgpPacket = newValue}
  }
  /// Returns true if `sgpPacket` has been explicitly set.
  public var hasSgpPacket: Bool {return _storage._sgpPacket != nil}
  /// Clears the value of `sgpPacket`. Subsequent reads from it will return its default value.
  public mutating func clearSgpPacket() {_uniqueStorage()._sgpPacket = nil}

  public var bmePacket: BMEPacket {
    get {return _storage._bmePacket ?? BMEPacket()}
    set {_uniqueStorage()._bmePacket = newValue}
  }
  /// Returns true if `bmePacket` has been explicitly set.
  public var hasBmePacket: Bool {return _storage._bmePacket != nil}
  /// Clears the value of `bmePacket`. Subsequent reads from it will return its default value.
  public mutating func clearBmePacket() {_uniqueStorage()._bmePacket = nil}

  public var blinkPacket: BlinkPacket {
    get {return _storage._blinkPacket ?? BlinkPacket()}
    set {_uniqueStorage()._blinkPacket = newValue}
  }
  /// Returns true if `blinkPacket` has been explicitly set.
  public var hasBlinkPacket: Bool {return _storage._blinkPacket != nil}
  /// Clears the value of `blinkPacket`. Subsequent reads from it will return its default value.
  public mutating func clearBlinkPacket() {_uniqueStorage()._blinkPacket = nil}

  public var shtPacket: SHTPacket {
    get {return _storage._shtPacket ?? SHTPacket()}
    set {_uniqueStorage()._shtPacket = newValue}
  }
  /// Returns true if `shtPacket` has been explicitly set.
  public var hasShtPacket: Bool {return _storage._shtPacket != nil}
  /// Clears the value of `shtPacket`. Subsequent reads from it will return its default value.
  public mutating func clearShtPacket() {_uniqueStorage()._shtPacket = nil}

  public var specPacket: SpecPacket {
    get {return _storage._specPacket ?? SpecPacket()}
    set {_uniqueStorage()._specPacket = newValue}
  }
  /// Returns true if `specPacket` has been explicitly set.
  public var hasSpecPacket: Bool {return _storage._specPacket != nil}
  /// Clears the value of `specPacket`. Subsequent reads from it will return its default value.
  public mutating func clearSpecPacket() {_uniqueStorage()._specPacket = nil}

  public var thermPacket: ThermPacket {
    get {return _storage._thermPacket ?? ThermPacket()}
    set {_uniqueStorage()._thermPacket = newValue}
  }
  /// Returns true if `thermPacket` has been explicitly set.
  public var hasThermPacket: Bool {return _storage._thermPacket != nil}
  /// Clears the value of `thermPacket`. Subsequent reads from it will return its default value.
  public mutating func clearThermPacket() {_uniqueStorage()._thermPacket = nil}

  public var imuPacket: IMUPacket {
    get {return _storage._imuPacket ?? IMUPacket()}
    set {_uniqueStorage()._imuPacket = newValue}
  }
  /// Returns true if `imuPacket` has been explicitly set.
  public var hasImuPacket: Bool {return _storage._imuPacket != nil}
  /// Clears the value of `imuPacket`. Subsequent reads from it will return its default value.
  public mutating func clearImuPacket() {_uniqueStorage()._imuPacket = nil}

  public var micPacket: MicPacket {
    get {return _storage._micPacket ?? MicPacket()}
    set {_uniqueStorage()._micPacket = newValue}
  }
  /// Returns true if `micPacket` has been explicitly set.
  public var hasMicPacket: Bool {return _storage._micPacket != nil}
  /// Clears the value of `micPacket`. Subsequent reads from it will return its default value.
  public mutating func clearMicPacket() {_uniqueStorage()._micPacket = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=5.5) && canImport(_Concurrency)
extension SensorPacketTypes: @unchecked Sendable {}
extension Tsl2591Gain: @unchecked Sendable {}
extension Tsl2591IntegrationTime: @unchecked Sendable {}
extension Sht45_precision: @unchecked Sendable {}
extension Sht45_heater: @unchecked Sendable {}
extension SensorPacketHeader: @unchecked Sendable {}
extension LuxPacket: @unchecked Sendable {}
extension LuxPacket.Payload: @unchecked Sendable {}
extension SGPPacket: @unchecked Sendable {}
extension SGPPacket.Payload: @unchecked Sendable {}
extension BMEPacket: @unchecked Sendable {}
extension BMEPacket.Payload: @unchecked Sendable {}
extension BlinkPacket: @unchecked Sendable {}
extension BlinkPacket.Payload: @unchecked Sendable {}
extension SHTPacket: @unchecked Sendable {}
extension SHTPacket.Payload: @unchecked Sendable {}
extension SpecPacket: @unchecked Sendable {}
extension SpecPacket.Payload: @unchecked Sendable {}
extension ThermPacket: @unchecked Sendable {}
extension ThermPacket.Payload: @unchecked Sendable {}
extension IMUPacket: @unchecked Sendable {}
extension IMUPacket.Payload: @unchecked Sendable {}
extension MicPacket: @unchecked Sendable {}
extension MicPacket.Payload: @unchecked Sendable {}
extension SensorPacket: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension SensorPacketTypes: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_PACKET_TYPE"),
    1: .same(proto: "PPG_RED"),
    2: .same(proto: "PPG_IR"),
    3: .same(proto: "SPECTROMETER"),
    4: .same(proto: "BME"),
    5: .same(proto: "CO2"),
    6: .same(proto: "IMU"),
    7: .same(proto: "THERMOPILE"),
    8: .same(proto: "LUX"),
    9: .same(proto: "LIDAR"),
    10: .same(proto: "MIC"),
    11: .same(proto: "SHT"),
    12: .same(proto: "SGP"),
    13: .same(proto: "BLINK"),
  ]
}

extension Tsl2591Gain: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TSL2722_GAIN_1X"),
    1: .same(proto: "TSL2722_GAIN_8X"),
    2: .same(proto: "TSL2722_GAIN_16X"),
    3: .same(proto: "TSL2722_GAIN_120X"),
  ]
}

extension Tsl2591IntegrationTime: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TSL2722_INTEGRATIONTIME_600MS"),
    192: .same(proto: "TSL2722_INTEGRATIONTIME_175MS"),
    219: .same(proto: "TSL2722_INTEGRATIONTIME_101MS"),
    246: .same(proto: "TSL2722_INTEGRATIONTIME_27_30MS"),
    255: .same(proto: "TSL2722_INTEGRATIONTIME_2_73MS"),
  ]
}

extension Sht45_precision: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SHT4X_HIGH_PRECISION"),
    1: .same(proto: "SHT4X_MED_PRECISION"),
    2: .same(proto: "SHT4X_LOW_PRECISION"),
  ]
}

extension Sht45_heater: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SHT4X_NO_HEATER"),
    1: .same(proto: "SHT4X_HIGH_HEATER_1S"),
    2: .same(proto: "SHT4X_HIGH_HEATER_100MS"),
    3: .same(proto: "SHT4X_MED_HEATER_1S"),
    4: .same(proto: "SHT4X_MED_HEATER_100MS"),
    5: .same(proto: "SHT4X_LOW_HEATER_1S"),
    6: .same(proto: "SHT4X_LOW_HEATER_100MS"),
  ]
}

extension SensorPacketHeader: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SensorPacketHeader"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "packet_type"),
    2: .standard(proto: "system_uid"),
    3: .standard(proto: "packet_id"),
    4: .standard(proto: "ms_from_start"),
    5: .same(proto: "epoch"),
    6: .standard(proto: "payload_length"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.packetType) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.systemUid) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.packetID) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.msFromStart) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.epoch) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.payloadLength) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.packetType != .unknownPacketType {
      try visitor.visitSingularEnumField(value: self.packetType, fieldNumber: 1)
    }
    if self.systemUid != 0 {
      try visitor.visitSingularUInt32Field(value: self.systemUid, fieldNumber: 2)
    }
    if self.packetID != 0 {
      try visitor.visitSingularUInt32Field(value: self.packetID, fieldNumber: 3)
    }
    if self.msFromStart != 0 {
      try visitor.visitSingularUInt32Field(value: self.msFromStart, fieldNumber: 4)
    }
    if self.epoch != 0 {
      try visitor.visitSingularUInt32Field(value: self.epoch, fieldNumber: 5)
    }
    if self.payloadLength != 0 {
      try visitor.visitSingularUInt32Field(value: self.payloadLength, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SensorPacketHeader, rhs: SensorPacketHeader) -> Bool {
    if lhs.packetType != rhs.packetType {return false}
    if lhs.systemUid != rhs.systemUid {return false}
    if lhs.packetID != rhs.packetID {return false}
    if lhs.msFromStart != rhs.msFromStart {return false}
    if lhs.epoch != rhs.epoch {return false}
    if lhs.payloadLength != rhs.payloadLength {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LuxPacket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "LuxPacket"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "gain"),
    2: .standard(proto: "integration_time"),
    3: .same(proto: "payload"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.gain) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.integrationTime) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.payload) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.gain != .tsl2722Gain1X {
      try visitor.visitSingularEnumField(value: self.gain, fieldNumber: 1)
    }
    if self.integrationTime != .tsl2722Integrationtime600Ms {
      try visitor.visitSingularEnumField(value: self.integrationTime, fieldNumber: 2)
    }
    if !self.payload.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.payload, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: LuxPacket, rhs: LuxPacket) -> Bool {
    if lhs.gain != rhs.gain {return false}
    if lhs.integrationTime != rhs.integrationTime {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LuxPacket.Payload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = LuxPacket.protoMessageName + ".Payload"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "lux"),
    2: .same(proto: "timestamp"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.lux) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.timestamp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.lux != 0 {
      try visitor.visitSingularUInt32Field(value: self.lux, fieldNumber: 1)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularUInt32Field(value: self.timestamp, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: LuxPacket.Payload, rhs: LuxPacket.Payload) -> Bool {
    if lhs.lux != rhs.lux {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SGPPacket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SGPPacket"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "payload"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.payload) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.payload.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.payload, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SGPPacket, rhs: SGPPacket) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SGPPacket.Payload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = SGPPacket.protoMessageName + ".Payload"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sraw_voc"),
    2: .standard(proto: "sraw_nox"),
    3: .standard(proto: "voc_index_value"),
    4: .standard(proto: "nox_index_value"),
    5: .same(proto: "timestamp"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.srawVoc) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.srawNox) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.vocIndexValue) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.noxIndexValue) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.timestamp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.srawVoc != 0 {
      try visitor.visitSingularUInt32Field(value: self.srawVoc, fieldNumber: 1)
    }
    if self.srawNox != 0 {
      try visitor.visitSingularUInt32Field(value: self.srawNox, fieldNumber: 2)
    }
    if self.vocIndexValue != 0 {
      try visitor.visitSingularInt32Field(value: self.vocIndexValue, fieldNumber: 3)
    }
    if self.noxIndexValue != 0 {
      try visitor.visitSingularInt32Field(value: self.noxIndexValue, fieldNumber: 4)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularUInt32Field(value: self.timestamp, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SGPPacket.Payload, rhs: SGPPacket.Payload) -> Bool {
    if lhs.srawVoc != rhs.srawVoc {return false}
    if lhs.srawNox != rhs.srawNox {return false}
    if lhs.vocIndexValue != rhs.vocIndexValue {return false}
    if lhs.noxIndexValue != rhs.noxIndexValue {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BMEPacket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "BMEPacket"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sample_period_ms"),
    2: .same(proto: "payload"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.samplePeriodMs) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.payload) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.samplePeriodMs != 0 {
      try visitor.visitSingularUInt32Field(value: self.samplePeriodMs, fieldNumber: 1)
    }
    if !self.payload.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.payload, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BMEPacket, rhs: BMEPacket) -> Bool {
    if lhs.samplePeriodMs != rhs.samplePeriodMs {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BMEPacket.Payload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BMEPacket.protoMessageName + ".Payload"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "time_stamp"),
    2: .same(proto: "signal"),
    3: .standard(proto: "signal_dimensions"),
    4: .standard(proto: "sensor_id"),
    5: .same(proto: "accuracy"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed64Field(value: &self.timeStamp) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.signal) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.signalDimensions) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.sensorID) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.accuracy) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.timeStamp != 0 {
      try visitor.visitSingularFixed64Field(value: self.timeStamp, fieldNumber: 1)
    }
    if self.signal != 0 {
      try visitor.visitSingularFloatField(value: self.signal, fieldNumber: 2)
    }
    if self.signalDimensions != 0 {
      try visitor.visitSingularUInt32Field(value: self.signalDimensions, fieldNumber: 3)
    }
    if self.sensorID != 0 {
      try visitor.visitSingularUInt32Field(value: self.sensorID, fieldNumber: 4)
    }
    if self.accuracy != 0 {
      try visitor.visitSingularUInt32Field(value: self.accuracy, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BMEPacket.Payload, rhs: BMEPacket.Payload) -> Bool {
    if lhs.timeStamp != rhs.timeStamp {return false}
    if lhs.signal != rhs.signal {return false}
    if lhs.signalDimensions != rhs.signalDimensions {return false}
    if lhs.sensorID != rhs.sensorID {return false}
    if lhs.accuracy != rhs.accuracy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BlinkPacket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "BlinkPacket"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "diode_saturation_flag"),
    2: .standard(proto: "blink_sample_rate"),
    3: .standard(proto: "subpacket_index"),
    4: .same(proto: "payload"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.diodeSaturationFlag) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.blinkSampleRate) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.subpacketIndex) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._payload) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.diodeSaturationFlag != 0 {
      try visitor.visitSingularUInt32Field(value: self.diodeSaturationFlag, fieldNumber: 1)
    }
    if self.blinkSampleRate != 0 {
      try visitor.visitSingularUInt32Field(value: self.blinkSampleRate, fieldNumber: 2)
    }
    if self.subpacketIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.subpacketIndex, fieldNumber: 3)
    }
    try { if let v = self._payload {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BlinkPacket, rhs: BlinkPacket) -> Bool {
    if lhs.diodeSaturationFlag != rhs.diodeSaturationFlag {return false}
    if lhs.blinkSampleRate != rhs.blinkSampleRate {return false}
    if lhs.subpacketIndex != rhs.subpacketIndex {return false}
    if lhs._payload != rhs._payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BlinkPacket.Payload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BlinkPacket.protoMessageName + ".Payload"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sample"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.sample) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sample.isEmpty {
      try visitor.visitSingularBytesField(value: self.sample, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BlinkPacket.Payload, rhs: BlinkPacket.Payload) -> Bool {
    if lhs.sample != rhs.sample {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SHTPacket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SHTPacket"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "precision"),
    2: .same(proto: "heater"),
    3: .same(proto: "payload"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.precision) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.heater) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.payload) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.precision != .sht4XHighPrecision {
      try visitor.visitSingularEnumField(value: self.precision, fieldNumber: 1)
    }
    if self.heater != .sht4XNoHeater {
      try visitor.visitSingularEnumField(value: self.heater, fieldNumber: 2)
    }
    if !self.payload.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.payload, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SHTPacket, rhs: SHTPacket) -> Bool {
    if lhs.precision != rhs.precision {return false}
    if lhs.heater != rhs.heater {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SHTPacket.Payload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = SHTPacket.protoMessageName + ".Payload"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "temperature"),
    2: .same(proto: "humidity"),
    3: .same(proto: "timestamp"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.temperature) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.humidity) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.timestamp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.temperature != 0 {
      try visitor.visitSingularFloatField(value: self.temperature, fieldNumber: 1)
    }
    if self.humidity != 0 {
      try visitor.visitSingularFloatField(value: self.humidity, fieldNumber: 2)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularUInt32Field(value: self.timestamp, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SHTPacket.Payload, rhs: SHTPacket.Payload) -> Bool {
    if lhs.temperature != rhs.temperature {return false}
    if lhs.humidity != rhs.humidity {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpecPacket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SpecPacket"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sample_period"),
    2: .same(proto: "payload"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.samplePeriod) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.payload) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.samplePeriod != 0 {
      try visitor.visitSingularUInt32Field(value: self.samplePeriod, fieldNumber: 1)
    }
    if !self.payload.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.payload, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SpecPacket, rhs: SpecPacket) -> Bool {
    if lhs.samplePeriod != rhs.samplePeriod {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpecPacket.Payload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = SpecPacket.protoMessageName + ".Payload"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "_415"),
    2: .standard(proto: "_445"),
    3: .standard(proto: "_480"),
    4: .standard(proto: "_515"),
    5: .standard(proto: "_clear_1"),
    6: .standard(proto: "_nir_1"),
    7: .standard(proto: "_555"),
    8: .standard(proto: "_590"),
    9: .standard(proto: "_630"),
    10: .standard(proto: "_680"),
    11: .standard(proto: "_clear_2"),
    12: .standard(proto: "_nir_2"),
    13: .same(proto: "flicker"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._415) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._445) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._480) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._515) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.clear1) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.nir1) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self._555) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self._590) }()
      case 9: try { try decoder.decodeSingularUInt32Field(value: &self._630) }()
      case 10: try { try decoder.decodeSingularUInt32Field(value: &self._680) }()
      case 11: try { try decoder.decodeSingularUInt32Field(value: &self.clear2) }()
      case 12: try { try decoder.decodeSingularUInt32Field(value: &self.nir2) }()
      case 13: try { try decoder.decodeSingularUInt32Field(value: &self.flicker) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self._415 != 0 {
      try visitor.visitSingularUInt32Field(value: self._415, fieldNumber: 1)
    }
    if self._445 != 0 {
      try visitor.visitSingularUInt32Field(value: self._445, fieldNumber: 2)
    }
    if self._480 != 0 {
      try visitor.visitSingularUInt32Field(value: self._480, fieldNumber: 3)
    }
    if self._515 != 0 {
      try visitor.visitSingularUInt32Field(value: self._515, fieldNumber: 4)
    }
    if self.clear1 != 0 {
      try visitor.visitSingularUInt32Field(value: self.clear1, fieldNumber: 5)
    }
    if self.nir1 != 0 {
      try visitor.visitSingularUInt32Field(value: self.nir1, fieldNumber: 6)
    }
    if self._555 != 0 {
      try visitor.visitSingularUInt32Field(value: self._555, fieldNumber: 7)
    }
    if self._590 != 0 {
      try visitor.visitSingularUInt32Field(value: self._590, fieldNumber: 8)
    }
    if self._630 != 0 {
      try visitor.visitSingularUInt32Field(value: self._630, fieldNumber: 9)
    }
    if self._680 != 0 {
      try visitor.visitSingularUInt32Field(value: self._680, fieldNumber: 10)
    }
    if self.clear2 != 0 {
      try visitor.visitSingularUInt32Field(value: self.clear2, fieldNumber: 11)
    }
    if self.nir2 != 0 {
      try visitor.visitSingularUInt32Field(value: self.nir2, fieldNumber: 12)
    }
    if self.flicker != 0 {
      try visitor.visitSingularUInt32Field(value: self.flicker, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SpecPacket.Payload, rhs: SpecPacket.Payload) -> Bool {
    if lhs._415 != rhs._415 {return false}
    if lhs._445 != rhs._445 {return false}
    if lhs._480 != rhs._480 {return false}
    if lhs._515 != rhs._515 {return false}
    if lhs.clear1 != rhs.clear1 {return false}
    if lhs.nir1 != rhs.nir1 {return false}
    if lhs._555 != rhs._555 {return false}
    if lhs._590 != rhs._590 {return false}
    if lhs._630 != rhs._630 {return false}
    if lhs._680 != rhs._680 {return false}
    if lhs.clear2 != rhs.clear2 {return false}
    if lhs.nir2 != rhs.nir2 {return false}
    if lhs.flicker != rhs.flicker {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ThermPacket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ThermPacket"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sample_period_ms"),
    2: .same(proto: "payload"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.samplePeriodMs) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.payload) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.samplePeriodMs != 0 {
      try visitor.visitSingularUInt32Field(value: self.samplePeriodMs, fieldNumber: 1)
    }
    if !self.payload.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.payload, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ThermPacket, rhs: ThermPacket) -> Bool {
    if lhs.samplePeriodMs != rhs.samplePeriodMs {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ThermPacket.Payload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ThermPacket.protoMessageName + ".Payload"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "descriptor"),
    2: .same(proto: "timestamp"),
    3: .standard(proto: "ambient_raw"),
    4: .standard(proto: "object_raw"),
    5: .standard(proto: "ambient_temp"),
    6: .standard(proto: "object_temp"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.descriptor) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.timestamp) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.ambientRaw) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.objectRaw) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self.ambientTemp) }()
      case 6: try { try decoder.decodeSingularFloatField(value: &self.objectTemp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.descriptor != 0 {
      try visitor.visitSingularUInt32Field(value: self.descriptor, fieldNumber: 1)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularUInt32Field(value: self.timestamp, fieldNumber: 2)
    }
    if self.ambientRaw != 0 {
      try visitor.visitSingularUInt32Field(value: self.ambientRaw, fieldNumber: 3)
    }
    if self.objectRaw != 0 {
      try visitor.visitSingularUInt32Field(value: self.objectRaw, fieldNumber: 4)
    }
    if self.ambientTemp != 0 {
      try visitor.visitSingularFloatField(value: self.ambientTemp, fieldNumber: 5)
    }
    if self.objectTemp != 0 {
      try visitor.visitSingularFloatField(value: self.objectTemp, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ThermPacket.Payload, rhs: ThermPacket.Payload) -> Bool {
    if lhs.descriptor != rhs.descriptor {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.ambientRaw != rhs.ambientRaw {return false}
    if lhs.objectRaw != rhs.objectRaw {return false}
    if lhs.ambientTemp != rhs.ambientTemp {return false}
    if lhs.objectTemp != rhs.objectTemp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension IMUPacket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "IMUPacket"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sample_period_ms"),
    2: .same(proto: "payload"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.samplePeriodMs) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._payload) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.samplePeriodMs != 0 {
      try visitor.visitSingularUInt32Field(value: self.samplePeriodMs, fieldNumber: 1)
    }
    try { if let v = self._payload {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: IMUPacket, rhs: IMUPacket) -> Bool {
    if lhs.samplePeriodMs != rhs.samplePeriodMs {return false}
    if lhs._payload != rhs._payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension IMUPacket.Payload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = IMUPacket.protoMessageName + ".Payload"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sample"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.sample) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sample.isEmpty {
      try visitor.visitSingularBytesField(value: self.sample, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: IMUPacket.Payload, rhs: IMUPacket.Payload) -> Bool {
    if lhs.sample != rhs.sample {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MicPacket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "MicPacket"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sample_freq"),
    2: .standard(proto: "system_sample_period"),
    3: .standard(proto: "samples_per_fft"),
    4: .standard(proto: "start_frequency"),
    5: .standard(proto: "frequency_spacing"),
    6: .same(proto: "payload"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.sampleFreq) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.systemSamplePeriod) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.samplesPerFft) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.startFrequency) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self.frequencySpacing) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._payload) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.sampleFreq != 0 {
      try visitor.visitSingularUInt32Field(value: self.sampleFreq, fieldNumber: 1)
    }
    if self.systemSamplePeriod != 0 {
      try visitor.visitSingularUInt32Field(value: self.systemSamplePeriod, fieldNumber: 2)
    }
    if self.samplesPerFft != 0 {
      try visitor.visitSingularUInt32Field(value: self.samplesPerFft, fieldNumber: 3)
    }
    if self.startFrequency != 0 {
      try visitor.visitSingularFloatField(value: self.startFrequency, fieldNumber: 4)
    }
    if self.frequencySpacing != 0 {
      try visitor.visitSingularFloatField(value: self.frequencySpacing, fieldNumber: 5)
    }
    try { if let v = self._payload {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MicPacket, rhs: MicPacket) -> Bool {
    if lhs.sampleFreq != rhs.sampleFreq {return false}
    if lhs.systemSamplePeriod != rhs.systemSamplePeriod {return false}
    if lhs.samplesPerFft != rhs.samplesPerFft {return false}
    if lhs.startFrequency != rhs.startFrequency {return false}
    if lhs.frequencySpacing != rhs.frequencySpacing {return false}
    if lhs._payload != rhs._payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MicPacket.Payload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = MicPacket.protoMessageName + ".Payload"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sample"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedFloatField(value: &self.sample) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sample.isEmpty {
      try visitor.visitPackedFloatField(value: self.sample, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MicPacket.Payload, rhs: MicPacket.Payload) -> Bool {
    if lhs.sample != rhs.sample {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SensorPacket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SensorPacket"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .standard(proto: "lux_packet"),
    3: .standard(proto: "sgp_packet"),
    4: .standard(proto: "bme_packet"),
    5: .standard(proto: "blink_packet"),
    6: .standard(proto: "sht_packet"),
    7: .standard(proto: "spec_packet"),
    8: .standard(proto: "therm_packet"),
    9: .standard(proto: "imu_packet"),
    10: .standard(proto: "mic_packet"),
  ]

  fileprivate class _StorageClass {
    var _header: SensorPacketHeader? = nil
    var _luxPacket: LuxPacket? = nil
    var _sgpPacket: SGPPacket? = nil
    var _bmePacket: BMEPacket? = nil
    var _blinkPacket: BlinkPacket? = nil
    var _shtPacket: SHTPacket? = nil
    var _specPacket: SpecPacket? = nil
    var _thermPacket: ThermPacket? = nil
    var _imuPacket: IMUPacket? = nil
    var _micPacket: MicPacket? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _header = source._header
      _luxPacket = source._luxPacket
      _sgpPacket = source._sgpPacket
      _bmePacket = source._bmePacket
      _blinkPacket = source._blinkPacket
      _shtPacket = source._shtPacket
      _specPacket = source._specPacket
      _thermPacket = source._thermPacket
      _imuPacket = source._imuPacket
      _micPacket = source._micPacket
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._header) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._luxPacket) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._sgpPacket) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._bmePacket) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._blinkPacket) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._shtPacket) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._specPacket) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._thermPacket) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._imuPacket) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._micPacket) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._header {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._luxPacket {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._sgpPacket {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._bmePacket {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._blinkPacket {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._shtPacket {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._specPacket {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._thermPacket {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._imuPacket {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._micPacket {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SensorPacket, rhs: SensorPacket) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._header != rhs_storage._header {return false}
        if _storage._luxPacket != rhs_storage._luxPacket {return false}
        if _storage._sgpPacket != rhs_storage._sgpPacket {return false}
        if _storage._bmePacket != rhs_storage._bmePacket {return false}
        if _storage._blinkPacket != rhs_storage._blinkPacket {return false}
        if _storage._shtPacket != rhs_storage._shtPacket {return false}
        if _storage._specPacket != rhs_storage._specPacket {return false}
        if _storage._thermPacket != rhs_storage._thermPacket {return false}
        if _storage._imuPacket != rhs_storage._imuPacket {return false}
        if _storage._micPacket != rhs_storage._micPacket {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
